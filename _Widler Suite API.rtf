{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deftab709{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}}
{\colortbl ;\red0\green0\blue0;\red0\green0\blue255;\red0\green0\blue128;}
{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
\pard\nowidctlpar\qc\kerning1\b\f0\fs36\lang1033 Widler Suite API\b0\fs24\par

\pard\nowidctlpar\par
The Widler Suite is a set of tools primarily intended for roguelike programmers using Java. This document serves as the primary reference for the API. Many functions are overloaded; these share a single description in most cases. \par
\par
Overwritten functions of interfaces and child classes are generally not described, even when public. If you need to overwrite any of these (things like ActionPerformed(ActionEvent) or paint(Graphics)), be sure to call super.functionName().\par
\par
For a demonstration of many of the following classes and functions, please run WidlerSuiteDemo.jar.\par
\par
Copyright Michael Widler, 2019. Permission granted for public or private use. No warranty of any kind is expressed or implied. If you use this suite in your project, please give credit.\par
\par
\par
\ul\b\fs28 AStar (class)\ulnone\b0\fs24\par
Implements: WSConstants\par
\i AStar is an implementation of the A* algorithm for pathfinding. This implementation operates on a boolean map (true = passable, false = impassable). It is primarily intended to be called with path().\i0\par
\par
\i Note: AStar uses AStarNode and AStarOpenList, which should not be directly called by the application programmer during normal use. As such, they are not documented here.\i0\par
\par
static int MAX_LOOPS\par
\i Maximum loops the algorithm will take, to prevent wasting time if no path exists. Default value is 5000.\i0\par
\par
static double HEURISTIC_MULTIPLER\par
\i Used to tune the algorithm. Default value is 11.0.\i0\par
\par
void setMode(int m)\par
\i Sets the search mode (which cells are considered adjacent). Accepts WSTools. RECT_MODE or WSTools.HEX_MODE, and defaults to the former. Search mode is static; this function will affect all subsequent searches, and as such is not thread safe.\i0\par
\par
void setSearchDiagonal(boolean sd)\par
\i Sets whether diagonally adjacent cells are considered adjecent when in rect mode.\i0\par
\par
AStar()\par
\i Empty constructor.\i0\par
\par
Vector<Coord> path(boolean[][] pm, Coord start, Coord end)\par
\cf1 Vector<Coord> path(boolean[][] pm, int startX, int startY, int endX, int endY)\cf0\par
\i Primary function. Attempts to make a path between start and end. Returns an empty vector if no such path exists, or if max iterations are performed.\i0\par
\par
void setMap(boolean[][] pm)\par
\i Makes a deep copy of a boolean map, and sets internal values accordingly.\i0\par
\par
Vector<Coord> getPath(Coord origin, Coord terminus)\par
Vector<Coord> getPath(int originX, int originY, int terminusX, int terminusY)\par
\i Determine a path and return it. Only works on an AStar instance that already has its map set.\i0\par
\par
\ul\b\fs28 AnimationManager (class)\ulnone\b0\fs24\par
Implements: ActionListener\par
\i This class does two things; it manages unbound strings for a RoguePanel, and has several static functions related to animation. Only the static functions are expected to be called, as each RoguePanel instantiates its own AnimationManager and interacts with it without user meddling. If being used as intended, there is no need for the application programmer to instantiate their own AnimationManager. For this reason, non-static public functions are not described here.\i0\par
\par
\i Note that AnimationManager receives actionPerformed calls from its parent RoguePanel; if you have non-timer ActionEvents being listened to by the RoguePanel, maybe you'll need to do something about that.\i0\par
\par
static void pause()\par
\i Pauses UmboundString processing, though not blinking nor pulsing.\i0\par
\par
static void unpause()\par
\i Unpauses UnboundString processing.\i0\par
\par
static void setThrottle(int t)\par
\i // ticks and pulses only increment every n ticks, where n = throttle\i0\par
\par
static boolean slowBlink()\par
\i Returns a boolean which alternates based on the timer hooked up to the parent RoguePanel. Default is 1 cycle per 60 ticks.\i0\par
\par
static boolean mediumBlink()\par
\i Returns a boolean which alternates based on the timer hooked up to the parent RoguePanel. Default is 1 cycle per 40 ticks.\i0\par
\par
static boolean fastBlink()\par
\i Returns a boolean which alternates based on the timer hooked up to the parent RoguePanel. Default is 1 cycle per 20 ticks.\i0\par
\par
static int slowPulse()\par
\i Returns an int which iterates based on the timer hooked up to the parent RoguePanel. Default is 0 to 20 to 0 inclusive, in steps of 1, at 1 step per tick.\i0\par
\par
static int mediumPulse()\par
\i Returns an int which iterates based on the timer hooked up to the parent RoguePanel. Default is 0 to 20 to 0 inclusive, in steps of 2, at 1 step per tick.\i0\par
\par
static int fastPulse()\par
\i Returns an int which iterates based on the timer hooked up to the parent RoguePanel. Default is 0 to 20 to 0 inclusive, in steps of 3, at 1 step per tick.\i0\par
\par
\ul\b\fs28 BinarySpacePartitioning (class)\ulnone\b0\fs24\par
\i This class is entirely static. Its intended purpose is to execute binary space partitioning on an area defined by partition(). It returns a list of all rooms, not just the final rooms, with the first being representing the total space and each subsequent pair representing sibilings. Which is to say, every pair of rooms n and n+1, with n being odd and greater than zero, are adjacent. See full algorithm at {\lang255{\field{\*\fldinst{HYPERLINK http://roguebasin.roguelikedevelopment.org/index.php?title=Basic_BSP_Dungeon_generation }}{\fldrslt{http://roguebasin.roguelikedevelopment.org/index.php?title=Basic_BSP_Dungeon_generation\ul0\cf0}}}}\i0\f0\fs24 . \par
\par
void setPartitionChance(double pc)\par
\i sets the chance that a room which is equal to or below maximum size will be further split, so long as the child rooms are still equal to or above minimum size.\i0\par
\par
static Vector<Room> partition(int x, int y, int minRoomDiameter, int maxRoomDiameter)\par
static Vector<Room> partition(Coord size, int minRoomDiameter, int maxRoomDiameter)\par
\i The main function. x and y determine total size. maxRoomDiameter must be at least twice minRoomDiameter, or it will be raised to that value.\i0\par
\par
\ul\b\fs28 Coord (class)\ulnone\b0\fs24\par
\i Coord is essentially a struct, with a bit more functionality. It is used to represent x-y pairs, such as Cartesian coordinates, height and width, etc. It has two public data members, x and y, and no other data. It is used fairly extensively throughout the Widler Suite.\i0\par
\par
int x, int y\par
\i The two data members. Both are public.\i0\par
\par
Coord()\par
\i Empty constructor. Default values are -1, -1.\i0\par
\par
Coord(int newX, int newY)\par
\i Constructor using ints.\i0\par
\par
Coord(Coord that)\par
\i Deep copy constructor.\i0\par
\par
Coord(int[] that)\par
\i Int array constructor. Chokes unless that[] has at least two members, and ignores anything beyond the first two.\i0\par
\par
Coord(Vect that)\par
\i Converts polar to rectangular coordinates. See the Vect class, below.\i0\par
\par
void copy(Coord that)\par
\i Deep copies an existing Coord into this one.\i0\par
\par
Coord copy()\par
\i Returns a deep copy of this object.\i0\par
\par
void add(Coord that)\par
\i Sums that Coord into this one (that is unchanged).\i0\par
\par
void subtract(Coord that)\par
\i Subtracts that Coord from this one (that is unchanged).\i0\par
\par
void set(Vect that)\par
\i Set this Coord by a Vect (converts mathematical vector to Cartesian coordinates).\i0\par
\par
double distanceTo(Coord that)\par
\i Return the distance between this Coord and another one.\i0\par
\par
boolean equals(Coord that)\par
\i Checks if two Coords are structurally equal.\i0\par
\par
boolean equals(int w, int h)\par
\i Checks if this Coord has identical data to the passed data.\i0\par
\par
boolean isAdjacent(Coord that)\par
\i Checks if this and that are adjacent (orthogonally or diagonally).\i0\par
\par
boolean isOrthogonallyAdjacent(Coord that)\par
\i Checks if this and that are orthogonally adjacent.\i0\par
\par
Vect getAsVect()\par
\i Returns this Coord as a Vect (converts Cartesian coordinates to mathematical vector).\i0\par
\par
double getMagnitude()\par
\i Converts the xy coordinates to a mathematical vector, and returns just the magnitude.\i0\par
\par
double getAngle()\par
\i Converts the xy coordinates to a mathematical vector, and returns just the angle.\i0\par
\par
String toString()\par
\i Returns a string representing the Coord, formatted as \ldblquote [x][y]\rdblquote .\i0\par
\par
static void removeDuplicates(Vector<Coord> list)\par
\i Traverses a (java.util.Vector, not WidlerSuite.Vect) of Coords and removes duplicates. This function modifies the Vector passed as an argument.\i0\par
\par
\ul\b\fs28 CP437 (interface)\ulnone\b0\fs24\par
\i This is an interface implementing the character set of code page 437. Primarily the UTF-8 characters are placed in a two-dimensional array of their CP437 locations, and many are given constants.\i0\par
\par
static final char[][] CP437_TABLE\par
\i A 16x16 table of the 256 characters.\i0\par
\par
\i Additionally, the following constants are also present, formatted for brevity. Constants do not represent the full array; in particular, box-drawing characters and characters which can be typed on a US keyboard.\i0\par
static final char SMILE_NO_FILL_CHAR, SMILE_FILL_CHAR, HEART_CHAR, DIAMOND_CHAR, CLUB_CHAR, SPADE_CHAR, DOT_FILL_CHAR, DOT_FILL_COMPLEMENT_CHAR, DOT_NO_FILL_CHAR, DOT_NO_FILL_COMPLEMENT_CHAR, MALE_CHAR, FEMALE_CHAR, NOTE_CHAR, DOUBLE_NOTE_CHAR, SUN_CHAR, RIGHT_TRIANGLE_CHAR, LEFT_TRIANGLE_CHAR, DOUBLE_VERTICAL_ARROW_CHAR, DOUBLE_EXCLAMATION_CHAR, PARAGRAPH_CHAR, DOUBLE_S_CHAR, SMALL_BOX_CHAR, UP_ARROW_CHAR, DOWN_ARROW_CHAR, RIGHT_ARROW_CHAR, LEFT_ARROW_CHAR, DOUBLE_HORIZONTAL_CHAR, UP_TRIANGLE_CHAR, DOWN_TRIANGLE_CHAR, DELETE_CHAR, CENT_CHAR, GBP_CHAR, YEN_CHAR, PTS_CHAR, FUNCTION_CHAR, INVERTED_QUESTION_MARK_CHAR, ONE_HALF_CHAR, ONE_QUARTER_CHAR, INVERTED_EXCLAMATION_MARK_CHAR, DOUBLE_LEFT_ARROW_CHAR, DOUBLE_RIGHT_ARROW_CHAR, LIGHT_SHADE_CHAR, MEDIUM_SHADE_CHAR, DARK_SHADE_CHAR, FULL_BLOCK_CHAR, LOWER_HALF_BLOCK_CHAR, LEFT_HALF_BLOCK_CHAR, RIGHT_HALF_BLOCK_CHAR, UPPER_HALF_BLOCK_CHAR, ALPHA_CHAR, BETA_CHAR, GAMMA_CHAR, PI_CHAR, CAPITAL_SIGMA_CHAR, SMALL_SIGMA_CHAR, MU_CHAR, TAU_CHAR, CAPITAL_PHI_CHAR, THETA_CHAR, OMEGA_CHAR, DELTA_CHAR, INFINITY_CHAR, SMALL_PHI_CHAR, EPSILON_CHAR, INTERSECTION_CHAR, TRIPLE_BAR_CHAR, PLUS_MINUS_CHAR, GTE_CHAR, LTE_CHAR, INTEGRAL_TOP_CHAR, INTEGRAL_BOTTOM_CHAR, DIVISION_CHAR, ALMOST_EQUAL_CHAR, DEGREE_CHAR, BULLET_CHAR, MIDDLE_DOT_CHAR, SQRT_CHAR, SUPERSCRIPT_N_CHAR, SUPERSCRIPT_2_CHAR, BLACK_SQUARE_CHAR, EMPTY_CHAR\par
\par
\ul\b\fs28 DijkstraMap (class)\ulnone\b0\fs24\par
Implements: WSConstants\par
\i Creates an int Dijkstra map of a passed boolean area, using any number of goals; calculates the distance from nearest goal. The expected use is that the application programmer will call the constructor, set goals as necessary, call process() or partiallyProcess(), then use the generated data as needed.\i0\par
\par
\i The default value of a cell is 1,000,000. As distances are kept in decisteps (10 decisteps = 1 actual step), if your mapping requires maps large enough that 100,000 steps is a valid data point, you're gonna get weirdness. And performance issues, most likely.\i0\par
\par
\i Having a large number of goals increases the execution time by n. Having a large area increases the execution time by n^2.\i0\par
\par
\i An implementation of the idea found at: http:  {\i0{\field{\*\fldinst{HYPERLINK "http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps" }}{\fldrslt{\ul\cf2\cf3\ul\i\lang255 www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps}}}}\i0\f0\fs24  \par
 \par
DijkstraMap(boolean[][] pm)\par
\i The constructor. Takes a pass map (false cells will be ignored during processing; that is, the algorithm goes around them).\i0\par
\par
void addGoal(Coord c)\par
void addGoal(int x, int y)\par
\i Add a goal to the list. Goals are the thing that the algorithm determines distance from.\i0\par
\par
boolean[][] getPassMap()\par
\i Returns a reference to the passability map. This is not a copy.\i0\par
\par
int[][] getMap()\par
\i Returns the Dijkstra map. Cell values are decisteps from nearest goal.\i0\par
\par
Vector<Coord> getGoalList()\par
\i Returns a reference to the list of goals. This is not a copy.\i0\par
\par
void setPassMap(boolean[][] p)\par
\i Sets the passability map. Doesn't error check, so if the new map's size is different than the last one, make a new instance of this class instead.\i0\par
\par
void setGoalList(Vector<Coord> g)\par
\i Overwrites the goal list with the passed one.\i0\par
\par
void setMode(int m)\par
\i Sets the diagonal mode (either WSConstants.RECT_MODE or WSConstants.HEX_MODE). Default behavior is rectangular grid.\i0\par
\par
void setSearchDiagonal(boolean d)\par
\i Sets whether, when in rect mode, the algorithm can step diagonally. Default behavior is true.\i0\par
\par
void clearGoalList()\par
\i Clears the list of goals.\i0\par
\par
int getValue(Coord c)\par
int getValue(int x, int y)\par
\i Returns the value of the passed cell of the output map. Returns the default cell value (1,000,000) for out-of-bounds cells.\i0\par
\par
int getStepValue(Coord c)\par
int getStepValue(int x, int y)\par
\i Returns the value of the passed cell of the output map, converted to steps. Returns the default cell value (100,000 steps) for out-of-bounds cells.\i0\par
\par
Vector<Coord> getLowestAdjacent(Coord c)\par
Vector<Coord> getLowestAdjacent(int xLoc, int yLoc)\par
\i Returns a list of all cells that share the lowest adjacent value.\i0\par
\par
Vector<Coord> getHighestAdjacent(Coord c)\par
Vector<Coord> getHighestAdjacent(int xLoc, int yLoc)\par
\i Returns a list of all cells that share the highest adjacent value.\i0\par
\par
void resetMap()\par
\i Readies the output map for another search, without changing the passability map.\i0\par
\par
void process()\par
\i Processes the entire output map. Clears it first, so you don't need to call resetMap().\i0\par
\par
void partiallyProcess(int startX, int startY, int endX, int endY)\par
void partiallyProcess(int startX, int startY, int endX, int endY, boolean mapIsSet)\par
\i Processes part of the map (which can be all of it). Only clears the output map (all of it) if mapIsSet == false. Passed locations are inclusive.\i0\par
\par
\ul\b\fs28 DijkstraRing (class)\ulnone\b0\fs24\par
\i Calculates concentric rings using a Dijkstra map. Generated on first call, and always considers diagonals valid.\i0\par
 \par
static Vector<Coord> getRing(int radius)\par
\i Returns a list of Coords in a set radius around [0,0]\i0\par
\par
\ul\b\fs28 FloodFill (class)\ulnone\b0\fs24\par
Implements WSConstants\par
\i An of a flood fill algorithm, intended to be used statically. Accepts a boolean array and starting location; false is impassable, true is passable. Returns a boolean array of the same size, where true is filled and false is not. Not thread safe (will collide with self).\i0\par
\par
static boolean[][] fill(boolean area[][], int x, int y)\par
static boolean[][] fill(boolean area[][], Coord loc)\par
\i Primary method. Returns a boolean array where true is filled, and false is what was not.\i0\par
\par
static boolean isInBounds(int x, int y)\par
\i Checks if the passed tile location is in the display bounds.\i0\par
\par
static void invertMap(boolean[][] map)\par
\i Not necessary, but often useful.\i0\par
\par
\ul\b\fs28 FontLoader (class)\ulnone\b0\fs24\par
\i A class for loading fonts, with some helper functions for checking size.\i0\par
\par
static String load(String fontFileName)\par
\i Loads the named font file (excluding the file extension) which must be a truetype font. Returns the system name of the font is successful, or null if unsuccessful.\i0\par
\par
static int getCharWidth(String fontName, int pointSize)\par
\i Returns the pixel width of the widest character in the passed font.\i0\par
\par
static int getCharHeight(String fontName, int pointSize)\par
\i Returns the pixel height of the tallest character in the passed font.\i0\par
\par
\ul\b\fs28 HexLine (class)\ulnone\b0\fs24\par
Extends: StraightLine\par
\i Creates a straight line between two points on a hex grid. I'll be super honest here; this one's got a dirty workaround in it. The only good solution I came up with involves handling the coordinates in an entirely different manner, and then it clashes with the rest of the suite. So it works fine, but if anyone has a cleaner solution shoot me an email.\i0\par
\par
\i Can be called directly or throught StraightLine, when StraightLine is in Hex Mode. Static.\i0\par
\par
static Vector<Coord> findLine(Coord tileOrigin, Coord tileTarget)\par
static Vector<Coord> findLine(Coord tileOrigin, Coord tileTarget, int arguments)\par
\i Returns the line between two points, subject to arguments.\i0\par
\par
\ul\b\fs28 MovementScript (class)\ulnone\b0\fs24\par
Implements: ActionListener\par
\i Contains a list of steps (changes in position) and impulses (changes in speed) to be applied to an UnboundString target (or child class). Passed to a RoguePanel with RoguePanel.add(), which then passes it off to the appropriate manager. Steps are executed once per tick.\i0\par
\par
\i Instances of MovementScript are kicked before their targets are, and do not kick their targets; targets should still be on either the locking or nonlocking list.\i0\par
\par
\i Note: MovementScript uses MovementScriptStep, which should not be directly called by the application programmer during normal use. As such, it is not documented here.\i0\par
\par
MovementScript(UnboundString us)\par
\i Constructor. Takes the target UnboundString as an argument.\i0\par
\par
UnboundString getTarget()\par
\i Returns the target UnboundString.\i0\par
\par
Vector<MovementScriptStep> getStepList()\par
\i Returns a list of the MovementScriptSteps to be executed (full list, regardless of where it is in that execution).\i0\par
\par
boolean loops()\par
\i Returns whether this script loops upon completion.\i0\par
\par
boolean expiresTargetOnEnd()\par
\i Returns whether or not this script manually expires its target upon completion.\i0\par
\par
int length()\par
\i Returns the number of steps/ticks in the script.\i0\par
\par
void setTarget(UnboundString t)\par
\i Set the target.\i0\par
\par
void setStepList(Vector<MovementScriptStep> s)\par
\i Set the steps.\i0\par
\par
void setLoops(boolean l)\par
\i Set whether or not the script loops.\i0\par
\par
void setExpiresTargetOnEnd(boolean e)\par
\i Set whether or not the script manually expires its target.\i0\par
\par
void setExpired(boolean e)\par
\i Manually sets whether this script is expired.\i0\par
\par
boolean isExpired()\par
\i Checks if the script is expired.\i0\par
\par
void setLength(int newLength)\par
\i Set the length of the script, in ticks.\i0\par
\par
void setImpulse(int tickIndex, double newXImpulse, double newYImpulse)\par
\i Set the impulse at a particular time. Will extend the script if passed tick does not exist.\i0\par
\par
void setOffset(int tickIndex, double newXOffsetAdj, double newYOffsetAdj)\par
\i Set the impulse at a particular time. Will extend the script if passed tick does not exist.\i0\par
\par
void setStep(int tickIndex, double newXImpulse, double newYImpulse, double newXOffsetAdj, double newYOffsetAdj)\par
\i Set both the impulse and step at a particular time. Will extend the script if passed tick does not exist.\i0\par
\par
void setStep(int tickIndex, MovementScriptStep newStep)\par
\i Copy a step into the script.\i0\par
\par
void clearStep(int tickIndex)\par
\i Clear a particular step.\i0\par
\par
void actionPerformed(ActionEvent ae)\par
\i Interface for ActionEvents. You shouldn't need to mess with this one.\i0\par
\par
\ul\b\fs28 NoiseChoir (class)\ulnone\b0\fs24\par
\i A class for layering multiple levels (octaves) of NoiseObjs. The user can control how many layers\i0\par
\i are present, how much each layer weighs comparatively (persistence), and how much each layer\i0\par
\i changes in frequency (inversely, the distance between samples).\i0\par
\par
\i Calls are done the same as for a NoiseObj; by calling getValue(double, double).\i0\par
\par
static int DEFAULT_OCTAVES\par
\i Default number of octaves (layers of noise). Defaults to 4.\i0\par
\par
static double DEFAULT_PERSISTENCE \par
\i Default level of persistence, which is the multiplicative amount a layer is weighted. In standard use should be in the range of (0, 1), so that successive layers have less weight. Defaults to .5 (each level is half as important as the previous).\i0\par
\par
static double DEFAULT_FREQUENCY_MULTIPLIER\par
\i How much the frequency is increased for each level. The space between each sample point is the reciprocal of frequency. Defaults to .5 (each level of noise is twice as large and sampled twice as wide as the previous).\i0\par
\par
NoiseObj[] getNoise()\par
\i Returns the array of NoiseObjs.\i0\par
\par
int getOctaves()\par
\i Returns the current number of octaves.\i0\par
\par
double getPersistence()\par
\i Returns the current level of persistence.\i0\par
\par
void setNoise(NoiseObj[] n)\par
\i Sets the octave array with a shallow copy.\i0\par
\par
void setOctaves(int o)\par
\i Sets the number of octaves (does not automatically call generate()).\i0\par
\par
void setPersistence(double p)\par
\i Sets the level of persistence (does not automatically call generate()).\i0\par
\par
NoiseChoir()\par
\i Default constructor, runs with default values (automatically calls generate()).\i0\par
\par
NoiseChoir(int oct)\par
\i Constructor specifying number of octaves (automatically calls generate()).\i0\par
\par
NoiseChoir(int oct, double pers)\par
\i Constructor specifying number of octaves and persistence (automatically calls generate()).\i0\par
\par
NoiseChoir(int oct, double pers, double freqMult)\par
\i Constructor specifying all the variables (automatically calls generate()).\i0\par
\par
void generate()\par
\i Sets the values for each NoiseObj.\i0\par
\par
double getValue(double xOff, double yOff)\par
\i Calculates and returns the value of a point. This is the one you'll call a lot.\i0\par
\par
\ul\b\fs28 NoiseObj (class)\ulnone\b0\fs24\par
\i A class for a Perlin-style noise, which automatically wraps. This generates a single octave \i0\par
\i of noise; see NoiseChoir  for layering them together. An octave of noise is a 2D array of doubles, where each element is in the range of (0.0, 1.0). The idea is to call points that lie between the vertices, and the NoiseObj will then calculate the value of that point based on how close they are to the four surrounding vertices. This is either scaled linearly (which yields angles) or by cosine interpolation (which yields smooth curves).\i0\par
\par
\i Essentially after creation, call in intervals << 1.0 to get smooth (or linear, your call)\i0\par
\i noise.\i0\par
\par
static final int DEFAULT_DIAMETER\par
\i Default size where the number of points stored is a 2D array.\i0\par
\par
double[][] getVertexArr()\par
\i Returns the entire vertex array.\i0\par
\par
boolean isSmooth()\par
\i Returns true if using cosine interpolation, or false if using linear interpolation.\i0\par
\par
int getWidth()\par
\i Returns the width (x-component) of the vertex array.\i0\par
\par
int getHeight()\par
\i Returns the height (y-component) of  the vertex array.\i0\par
\par
void setVertexArr(double[][] v)\par
\i Set the entire vertex array.\i0\par
\par
void setSmooth(boolean s)\par
\i Set the type if interpolation; smooth (true) or linear (false).\i0\par
\par
NoiseObj()\par
\i Default constructor.\i0\par
\par
NoiseObj(int width, int height)\par
\i Constructs and populates a NoiseObj with set dimensions.\i0\par
\par
void generate()\par
void generate(int width, int height)\par
\i Reset the array and regenerate values.\i0\par
\par
double getValue(double xOff, double yOff)\par
\i Calculates and returns the value of a point. This is the one you'll call a lot.\i0\par
\par
\ul\b\fs28 RectLine (class)\ulnone\b0\fs24\par
Extends: StraightLine\par
\i Creates a straight line between two points on a rectangular grid. This is an implementation of Bresenham's Line. Can be called directly or through StraightLine when StraightLine is in Rect Mode. Static.\i0\par
\par
static Vector<Coord> findLine(Coord origin, Coord target)\par
static Vector<Coord> findLine(Coord origin, Coord target, int arguments)\par
\i Returns the line between two points, subject to arguments.\i0\par
\par
\ul\b\fs28 RoguePanel (class)\ulnone\b0\fs24\par
Extends JPanel \par
Implements ComponentListener, ActionListener, MouseListener, MouseMotionListener, WSConstants\par
\i A class for a curses implementation. Everything is pretty much handled internally, except for being hooked up to a timer (which is passed on to the unbound string stuff, as long as this panel is visible).\i0\par
\par
\i Internally, RoguePanel keeps three two-dimensional arrays; one for background color, one for foreground color, and one for foreground strings. Additionally, each instance has its own AnimationManager, for displaying UnboundStrings. Also, a RoguePanel has an out-of-bounds tile who's values are returned when the user attempts to get a tile that does not exist.\i0\par
\par
\i RoguePanel is not designed to be a map structure, which is to say that it does not hold data it does not intend to display (with a few exceptions). So it does not scroll through a large area, only displaying part of it; if that's how your map operates, the map should only pass down the part that is being used.\i0\par
\par
\i I thought of having an interface for map cells, but as most ASCII roguelikes seem to load the three values from the map, overwrite some with items, then overwrite some with actors, and then again possibly with visual effects, which is beyond the scope of this class, I decided against it.\i0\par
\par
\i Note getMouseColumn() and getMouseRow() are intended to be called when external mouseListeners and mouseMotionListeners recieve events, but whatever floats your goat.\i0\par
\par
Font getFont()\par
\i Returns a shallow copy of the current font for strings.\i0\par
\par
String getFontName()\par
\i Returns the proper name of the current font.\i0\par
\par
Color getTileBorderColor()\par
\i Returns the border color of each tile when showBorder is set to true.\i0\par
\par
Color getOOBBGColor()\par
\i Gets the color for the out-of-bounds tile background.\i0\par
\par
Color getOOBFGColor()\par
\i Gets the color for the out-of-bounds tile foreground.\i0\par
\par
String getOOBBGString()\par
\i Gets the string for the out-of-bounds tile.\i0\par
\par
double getXScroll()\par
\i Returns the current horizontal display displacement in tiles.\i0\par
\par
double getYScroll()\par
\i Returns the current vertical display displacement in tiles.\i0\par
\par
boolean hasTightFontBorders()\par
\i Returns whether the tile sizing is optimized for monosized fonts.\i0\par
\par
int columns()\par
\i Returns the number of columns to be displayed.\i0\par
\par
int rows()\par
\i Returns the number of rows to be displayed.\i0\par
\par
int mouseColumn()\par
\i Returns the index of the column in which the mouse is currently located, or -1 if the mouse is not in a column.\i0\par
\par
int mouseRow()\par
\i Returns the index of the row in which the mouse is currently located, or -1 if the mouse is not in a row.\i0\par
\par
void setFontName(String f)\par
\i Sets the font based on the name string passed in.\i0\par
\par
void showTileBorders(boolean sb)\par
\i Set whether each tile has a border.\i0\par
\par
void setTileBorderColor(Color bc)\par
\i Set the border color for each tile.\i0\par
\par
void setOOBBGColor(Color c)\par
\i Set the out-of-bounds tile's background color.\i0\par
\par
void setOOBFGColor(Color c)\par
\i Set the out-of-bounds tile's foreground color.\i0\par
\par
void setOOBString(String s)\par
\i Set the out-of-bounds tile's foreground string.\i0\par
\par
void setScroll(double x, double y)\par
\i Set display displacement (ignoring screen shake, padding, etc) in tiles.\i0\par
\par
void setTightFontBorders(boolean tfb)\par
\i Sets if tile size is optimized for monosized (note: not just monospaced, but monosized) fonts.\i0\par
\par
RoguePanel()\par
\i Empty constructor. Defaults to 15x15.\i0\par
\par
RoguePanel(int w, int h)\par
\i Size-based constructor; creates a RoguePanel with w columns and h rows.\i0\par
\par
boolean isInBounds(Coord loc)\par
boolean isInBounds(int x, int y)\par
\i Checks if the passed tile location is in the display bounds.\i0\par
\par
boolean isShaking()\par
\i Checks if the screen is currently shaking\i0\par
\par
void randomize()\par
\i Assigns random values to each cell. Mostly used for testing.\i0\par
\par
void setColumnsAndRows(Coord size)\par
void setColumnsAndRows(int x, int y)\par
\i Sets the RoguePanel to have x columns and y rows.\i0\par
\par
void setFGColor(Coord loc, Color c)\par
void setFGColor(int x, int y, Color c)\par
\i Set foreground color of a specific tile.\i0\par
\par
void setBGColor(Coord loc, Color c)\par
void setBGColor(int x, int y, Color c)\par
\i Set background color of a specific tile.\i0\par
\par
void setString(Coord loc, String s)\par
void setString(int x, int y, String s)\par
\i Set the string (generally one character) of a specific tile.\i0\par
\par
void setTile(Coord loc, String s, Color fg, Color bg)\par
void setTile(int x, int y, String s, Color fg, Color bg)\par
\i Set a tile's values all at once.\i0\par
\par
void setTile(Coord loc, String s, Color fg)\par
void setTile(int x, int y, String s, Color fg)\par
\i Set a tile's foreground values all at once.\i0\par
\par
void setDisplayMode(int dm)\par
\i Set the display to either rect (orthoginal) or hex (diagonal), using constants from WSConstants.\i0\par
\par
void setScreenShake(double radius, int duration)\par
void setScreenShake(double radiusX, double radiusY, int duration)\par
\i Set screen shake. Overwrites any existing screen shake. radius values are in tiles, duration is in ticks.\i0\par
\par
void setBGBox(Coord loc, Coord size, Color c)\par
void setBGBox(int x, int y, int w, int h, Color c)\par
\i Set a rectangular area of backgrounds to a single color.\i0\par
\par
void setFGBox(Coord loc, Coord size, Color c)\par
void setFGBox(int x, int y, int w, int h, Color c)\par
\i Set a rectangular area of foregrounds to a single color.\i0\par
\par
void setFGBox(Coord loc, Coord size, String s, Color c)\par
void setFGBox(int x, int y, int w, int h, String s, Color c)\par
\i Set a rectangular area of the foreground to a single string and color.\i0\par
\par
void write(Coord loc, String str, Color c)\par
void write(int x, int y, String str, Color c)\par
\i Write a string in sequential tiles.\i0\par
\par
void writeBox(Coord loc, Coord box, String str, Color c)\par
void writeBox(int xStart, int yStart, int w, int h, String str, Color c)\par
\i Write a string inside an area, with word wrapping.\i0\par
\par
Color getFGColor(Coord loc)\par
Color getFGColor(int x, int y)\par
\i Returns the foreground color of the passed location.\i0\par
\par
Color getBGColor(Coord loc)\par
Color getBGColor(int x, int y)\par
\i Returns the background color of the passed location.\i0\par
\par
String getString(Coord loc)\par
String getString(int x, int y)\par
\i Returns the string of the passed location.\i0\par
\par
void addLocking(UnboundString us)\par
\i Add a locking unbound string (passed to the animation manager).\i0\par
\par
void addNonlocking(UnboundString us)\par
void add(UnboundString us)\par
\i Add a non-locking unbound string (passed to the animation manager).\i0\par
\par
void remove(UnboundString us)\par
\i Removes the passed unbound string, if it is currently on the locking or non-locking list of the animation manager.\i0\par
\par
void add(MovementScript ms)\par
\i Adds the passed MovementScript to the animation manager.\i0\par
\par
void remove(MovementScript ms)\par
\i Removes the passed movement script, if it is currently on the script list of the animation manager.\i0\par
\par
boolean isAnimationLocked()\par
\i Check if external processes should be delayed while waiting for animation to complete.\i0\par
\par
void clearUnboundStrings()\par
\i Clear all the unbound string lists.\i0\par
\par
void setCornerCell(Coord loc)\par
void setCornerCell(int x, int y)\par
\i Set the corner cell, for properly displaying unbound strings. The corner cell is the index of the upper rightmost displayed tile.\i0\par
\par
void setCenterCell(Coord loc)\par
void setCenterCell(int x, int y)\par
\i Set the corner cell by passing the center cell.\i0\par
\par
\ul\b\fs28 Room (class)\ulnone\b0\fs24\par
\i A class used by the BSP generator. Keeps track of abstract rooms. Child rooms are made by splitting a single parent room. More or less a struct.\i0\par
\i Modeled after the algorithm at: {\lang255{\field{\*\fldinst{HYPERLINK http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation }}{\fldrslt{http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation\ul0\cf0}}}}\i0\f0\fs24\par
\par
\par
Coord origin\par
\i xy coordinate of the upper left corner of the room.\i0\par
\par
Coord size\par
\i Width (x) and height (y) of the room.\i0\par
\par
int iteration\par
\i How many split iterations it took to create this room.\i0\par
\par
boolean isParent\par
\i True if any child rooms been made out of this one.\i0\par
\par
Room()\par
\i Empty constructor.\i0\par
\par
boolean contains(Coord loc)\par
boolean contains(int x, int y)\par
\i Checks if the room contains the passed location.\i0\par
\par
boolean isParentOf(Room that)\par
\i Checks if this room is the parent of the passed room, strictly by checking iterations.\i0\par
\par
Coord getCenter()\par
\i Returns a Coord corresponding to the center of this room.\i0\par
\par
boolean equals(Room that)\par
\i Checks if two rooms are equivalent (have equal origins and sizes).\i0\par
\par
boolean isHorizontallyAdjacent(Room that)\par
boolean isHorizontallyAdjacent(Room that, boolean findSibiling)\par
\i Returns true if the right boundary of this room and the left boundary of that room are in adjacent columns. If findSibiling is true, then checks the opposite as well (right of that adjacent to left of this).\i0\par
\par
boolean isVerticallyAdjacent(Room that)\par
boolean isVerticallyAdjacent(Room that, boolean findSibiling)\par
\i Returns true if the bottom boundary of this room and the top boundary of that room are in adjacent columns. If findSibiling is true, then checks the opposite as well (bottom of that adjacent to top of this).\i0\par
\par
Coord getRandomCell()\par
\i Returns a random location within the room.\i0\par
\par
\ul\b\fs28 ShadowFoV (abstract class)\ulnone\b0\fs24\par
Implements: WSConstants\par
\i Abstract parent class for ShadowFoVHex and ShadowFoVRect. Reduces code duplication, ensures consistent interface, allow objects to be unaware of what kind of FoV they're using.\i0\par
\par
ShadowFoV(boolean[][] transpMap)\par
\i Constructor. Requires a boolean map where true is transparent, and false blocks line of sight. This is held as a shallow copy, so changes to the original will be carried over.\i0\par
\par
void reset(boolean[][] transpMap)\par
\i Changes the transparency map. Again, this is a shallow copy and this function generally only needs to be called if an entirely different transparency map is needed.\i0\par
\par
boolean isInBounds(int x, int y)\par
boolean isInBounds(Coord loc)\par
\i Checks if the passed location is inside the map bounds.\i0\par
\par
boolean blocksLoS(int x, int y)\par
boolean blocksLoS(Coord loc)\par
\i Checks if a square blocks LoS.\i0\par
\par
boolean isVisible(int x, int y)\par
boolean isVisible(Coord loc)\par
\i Checks if a square is visible, based on the last calcFoV call.\i0\par
\par
boolean[][] getArray(int startX, int startY, int w, int h)\par
\i Returns a deep copy of the visibility array, bounded by the passed constraints.\i0\par
\par
abstract void calcFoV(int xLoc, int yLoc, int radius)\par
\i This is the main method to implement in child classes.\i0\par
\par
\ul\b\fs28 ShadowFoVHex (class)\ulnone\b0\fs24\par
Extends: ShadowFoV\par
\i An implementation of shadowcasting FoV for hex modes. Checks if the center of a tile has LoS to at least one of six points on the target tile. Does not need to be reset in between runs.\i0\par
\par
\i Basic procedure:\i0\par
\i    The cell's neighbors are added to the process list (checking if in bounds, in range and\i0\par
\i       not already added for each)\i0\par
\i    If a cell is in shadow, it is skipped\i0\par
\i    The cell is marked as visible\i0\par
\i    If the cell is not transparent, it registers a shadow.\i0\par
\par
\i Shadows:\i0\par
\i A shadow is two angles; anything entirely occluded by shadows cannot be seen. Some tiles are occluded by multiple shadows (that is, no shadow covers all six points, but all six points are in shadow). As tiles are searched in an outward spiraling pattern, it is not necessary to note a shadow's starting point.\i0\par
\par
ShadowFoVHex(boolean[][] transpMap)\par
\i Basic constructor.\i0\par
\par
void set(boolean[][] transpMap)\par
\i Prepares the arrays to be run; does not need to be called between runs unless the map changes.\i0\par
\par
void calcFoV(int xLoc, int yLoc, int radius)\par
\i Calculate lit squares from a given location and radius.\i0\par
\par
\ul\b\fs28 ShadowFoVRect (class)\ulnone\b0\fs24\par
Extends: ShadowFoV\par
\i An implementation of a shadow casting FoV algorithm. This is my translation of Bj\'f6rn Bergstr\'f6m's Python implementation. Made to be persistent; just call calcFoV() with a new origin, or after updating the transparency map.\i0\par
\par
\i To be honest, while I understand the idea, the actual implementation is a little dense for me. Don't ask me to pick this one apart for you.\i0\par
\par
\i Description:\i0\par
{\i\lang255{\field{\*\fldinst{HYPERLINK http://roguebasin.roguelikedevelopment.org/index.php?title=FOV_using_recursive_shadowcasting }}{\fldrslt{http://roguebasin.roguelikedevelopment.org/index.php?title=FOV_using_recursive_shadowcasting\ul0\cf0}}}}\f0\fs24  \par
\par
\i Original Implementation:\i0\par
{\i\lang255{\field{\*\fldinst{HYPERLINK http://roguebasin.roguelikedevelopment.org/index.php?title=PythonShadowcastingImplementation }}{\fldrslt{http://roguebasin.roguelikedevelopment.org/index.php?title=PythonShadowcastingImplementation\ul0\cf0}}}}\f0\fs24\par
\par
ShadowFoVRect(boolean[][] transpMap)\par
\i Basic constructor.\i0\par
\par
void calcFoV(int xLoc, int yLoc, int radius)\par
\i Calculate visible squares from a given location and radius.\i0\par
\par
\ul\b\fs28 SmoothCA (class)\ulnone\b0\fs24\par
Implements: WSConstants\par
\i A smoothing cellular automata class. Iterates over a copy of a 2D boolean array, making each cell more like its neighbors. The original boolean map is not modified.\i0\par
\i     \i0\par
\i In rect mode, a tile is set to false if 5 of the 9 tiles in the 3x3 area centered on it are false, else it is set to true.\i0\par
\i     \i0\par
\i In hex mode, a tile is set to false if 4 of the 7 tiles made up of itself and all adjacent tiles are false, else it is set to true.\i0\par
\par
boolean[][] getMap()\par
\i Returns a shallow copy of the current map. Running process() replaces the map, rather than modifying it, but if you call getMap(), tweak the data, then call process(), your changes will carry over to the new map.\i0\par
\par
SmoothCA(boolean[][] searchableMap)\par
SmoothCA(boolean[][] searchableMap, int tileMode)\par
\i Basic constructors. tileMode refers to WSConstants.HEX_MODE and WSConstants.RECT_MODE (rect is the default). Calling the constructor also runs process() once.\i0\par
\par
static boolean[][] smooth(boolean[][] bm)\par
static boolean[][] smooth(boolean[][] bm, int iterations)\par
static boolean[][] smooth(boolean[][] bm, int iterations, int tileMode)\par
\i A static method for when the object is unnecessary.\i0\par
\par
void process()\par
\i Runs a single iteration of smoothing.\i0\par
\par
\ul\b\fs28 SpiralSearch (class)\ulnone\b0\fs24\par
Implements: WSConstants\par
\i After calling the constructor, each call to getNext() returns the next Coord in an increasing spiral. Part of calling the constructor is defining what tiles can be searched; unsearchable tiles also block the search (that is, this is a step-by-step flood fill).\i0\par
\par
\i getNext() returns null if no tiles remain to be searched.\i0\par
\par
\i The intended use is to find something that may or may not exist, when a location isn't known, or when you want to find the closest instance of a particular thing.\i0\par
\par
\i The algorithm only processes a couple tiles ahead of where getNext() is to maintain performance and limit unnecessary memory usage.\i0\par
\par
SpiralSearch(boolean area[][], int startX, int startY, int tileMode, boolean diag)\par
SpiralSearch(boolean area[][], Coord startLoc, int tileMode, boolean diag)\par
SpiralSearch(boolean area[][], Coord startLoc)\par
SpiralSearch(boolean area[][], int startX, int startY)\par
\i Various constructors. Default behavior is diagonal searching = true, tileMode = rect.\i0\par
\par
Coord getNext()\par
\i Returns the next Coord in the queue, and does a bit more searching if needed.\i0\par
\par
\ul\b\fs28 StraightLine (class)\ulnone\b0\fs24\par
Implements: WSConstants\par
\i Used for calculating a list of tiles which lie on a line, this class calls down to the appropropriate child class (rect or hex), and holds the shared functions those two children need.\i0\par
\par
\i HexLine and RectLine can also be called directly, if preferred.\i0\par
\par
static final int REMOVE_ORIGIN\par
static final int REMOVE_TARGET\par
static final int REMOVE_ORIGIN_AND_TARGET\par
\i Final static variables for trimming ends.\i0\par
\par
static void setRoundToEven(boolean r)\par
\i Set whether lines will round normally, or round to even ints. Default is to round to even (this makes line a to b the same as line b to a).\i0\par
\par
static void setMode(int m)\par
\i Set the mode to either WSConstants.RECT_MODE or WSConstants.HEX_MODE. Default is rect.\i0\par
\par
static Vector<Coord> findLine(Coord origin, Coord target)\par
static Vector<Coord> findLine(Coord origin, Coord target, int arguments)\par
\i Returns the line between two points, subject to arguments.\i0\par
\par
\ul\b\fs28 UnboundString (class)\ulnone\b0\fs24\par
Implements: ActionListener, WSConstants\par
\i A class representing strings (and possibly a simple background behind the string) which are not bound to the RoguePanel's standard display grid. They have a defined lifespan, measured in ticks, and are removed when they expire.\i0\par
\par
static final Color TRANSPARENT_BLACK\par
\i Transparent black is a good background color for UnboundStrings, so it's part of the class.\i0\par
\par
static final boolean GRAVITY_DEFAULT\par
\i Whether or not UnboundStrings are affected by gravity by default. Defaults to false.\i0\par
\par
static final int ROUNDED_RECT\par
static final int RECT\par
static final int OVAL\par
static final int CIRCLE\par
\i A group of signals for setting the type of background box.\i0\par
\par
Color getBGColor()\par
\i Returns the color of the background box.\i0\par
\par
Color getFGColor()\par
\i Returns the color of the string.\i0\par
\par
String getString()\par
\i Returns the string.\i0\par
\par
Coord getLoc()\par
\i Returns the location, in tiles, of the UnboundString.\i0\par
\par
int getXLoc()\par
\i Returns the x location, in tiles, of the UnboundString.\i0\par
\par
int getYLoc()\par
\i Returns the y location, in tiles, of the UnboundString.\i0\par
\par
double getXOffset()\par
\i Returns the offset, in tiles, from the base x location.\i0\par
\par
double getYOffset()\par
\i Returns the offset, in tiles, from the base y location.\i0\par
\par
boolean hasBackgroundBox()\par
\i Returns whether or not the UnboundString is displayed in front of a background box.\i0\par
\par
int getBackgroundBoxType()\par
\i Returns the type of background box, matching ROUNDED_RECT, RECT, OVAL, or CIRCLE.\i0\par
\par
static int getDefaultLifespan()\par
\i Returns the default lifespan, in ticks, of UnboundStrings.\i0\par
\par
static void setDefaultLifespan(int dl)\par
\i Set the default lifespan of new UnboundStrings.\i0\par
\par
boolean isAffectedByGravity()\par
\i Returns whether or not this particular UnboundString is affected by gravity.\i0\par
\par
boolean isAffectedByAge()\par
\i Returns whether or not this particular UnboundString is affected by age, and thus will expire normally.\i0\par
\par
boolean isVisible()\par
\i Returns whether or not this particular UnboundString should be drawn.\i0\par
\par
void setBGColor(Color b)\par
\i Sets the background box color.\i0\par
\par
void setFGColor(Color f)\par
\i Sets the foreground color.\i0\par
\par
void setString(String s)\par
\i Sets the foreground string.\i0\par
\par
void setLoc(int x, int y)\par
void setLoc(Coord l)\par
\i Sets the location, in tiles.\i0\par
\par
void setXLoc(int x)\par
\i Sets the x location, in tiles.\i0\par
\par
void setYLoc(int y)\par
\i Sets the y location, in tiles.\i0\par
\par
void setXOffset(double x)\par
\i Sets the x offset, in tiles.\i0\par
\par
void setYOffset(double y)\par
\i Sets the y offset, in tiles.\i0\par
\par
void setBackgroundBox(boolean b)\par
\i Sets whether or not a background is shown behind the string.\i0\par
\par
void setBackgroundBoxType(int bt)\par
\i Sets the type of background box.\i0\par
\par
void setLifespan(int l)\par
\i Sets the maximum lifespan, in ticks.\i0\par
\par
void setAge(int a)\par
\i Sets the current age. Once age == lifespan, the UnboundString expires.\i0\par
\par
void setAffectedByGravity(boolean abg)\par
\i Set whether or not this UnboundString is affected by gravity.\i0\par
\par
void setAffectedByAge(boolean aba)\par
\i Set whether or not this UnboundString is affected by age.\i0\par
\par
\par
void setVisible(boolean v)\par
\i Set whether or not this UnboundString should be displayed. Non-visible objects will still be kicked by the animation manager.\i0\par
\par
UnboundString(String s)\par
\i Basic constructor.\i0\par
\par
UnboundString(String s, Color fg, Coord l)\par
UnboundString(String s, Color fg, int x, int y)\par
\i Setting constructors.\i0\par
\par
UnboundString(UnboundString that)\par
\i Copy constructor.\i0\par
\par
boolean isExpired()\par
\i Checks if an UnboundString should be removed by the manager.\i0\par
\par
void forceExpire()\par
\i Causes an UnboundString, even one not affected by age, to expire.\i0\par
\par
void setSpeed(double x, double y)\par
\i How many tiles are moved each tick. By default, UnboundStrings are stationary.\i0\par
\par
\ul\b\fs28 UnboundTile (class)\ulnone\b0\fs24\par
Extends: UnboundString\par
Implements: WSConstants\par
\i An extension of UnboundString for tile-sized elements. Displayed by RoguePanel a little differently, and always has a background.\i0\par
\par
\i Note: A little buggy right now.\i0\par
\par
UnboundTile(String s)\par
UnboundTile(String s, Color fg, Coord loc)\{this(s, fg, l.x, l.y);\}\par
UnboundTile(String s, Color fg, int xLoc, int yLoc)\par
UnboundTile(UnboundTile that)\par
\i Various constructors.\i0\par
\par
\ul\b\fs28 Vect (class)\ulnone\b0\fs24\par
Implements: WSConstants\par
\i A simple mathematical vector system for WidlerSuite. Plays nicely with Coord. More or less a struct.\i0\par
\par
double angle\par
\i In radians.\i0\par
\par
double magnitude\par
\i The other public member.\i0\par
\par
Vect()\par
\i Empty constructor.\i0\par
\par
Vect(double theta, double length)\par
\i Double constructor.\i0\par
\par
Vect(double theta, int length)\par
\i Double/int constructor.\i0\par
\par
Vect(Coord cart)\par
\i Constructor that converts a Coord to a Vect (converts Cartesian to polar coordinates).\i0\par
\par
Vect(Vect that)\par
\i Basic copy constructor.\i0\par
\par
Vect(Coord origin, Coord terminus)\par
\i Constructor that sets the Vect to the vector that points from origin to terminus.\i0\par
\par
Vect copy()\par
\i Returns a deep copy of this.\i0\par
\par
void set(double a, double m)\par
void set(double a, int m)\par
void set(Vect that)\par
\i Sets the Vect based on the passed data.\i0\par
\par
void set(Coord origin, Coord terminus)\par
\i Sets the Vect equal to the difference of the passed Coords.\i0\par
\par
void set(Coord cart)\par
\i Converts the Coord from Cartesian to polar coordinates, then sets this to that.\i0\par
\par
int getX()\par
\i Converts the Vect to Cartesian coordinates and returns the x component.\i0\par
\par
int getY()\par
\i Converts the Vect to Cartesian coordinates and returns the y component.\i0\par
\par
double getXAsDouble()\par
\i Converts the Vect to Cartesian coordinates and returns the x component.\i0\par
\par
double getYAsDouble()\par
\i Converts the Vect to Cartesian coordinates and returns the y component.\i0\par
\par
void add(Vect that)\par
\i Adds another Vect to this one. Can result in loss of precision, as it converts to Coords which are int-based.\i0\par
\par
void add(Coord that)\par
\i Adds a Coord to this by converting this to a Coord, adding, and converting back to a Vect.\i0\par
\par
boolean equals(Vect that)\par
\i Checks for equality.\i0\par
\par
Coord getAsCoord()\par
\i Converts this to a Coord and returns the result.\i0\par
\par
\ul\b\fs28 Voronoi (class)\ulnone\b0\fs24\par
\i An implementation of Voronoi diagramming.\i0\par
\par
\i Accepts a list of points and an array size, returns a Voronoi map. The map is represented\i0\par
\i as a two-dimensional int array, with the value stored being the Vector index of the point\i0\par
\i closest. A second two-dimensional array is used internally to track best so far during generation.\i0\par
\par
static boolean ANGBAND\par
static boolean TRUE_DIST\par
\i Mode flags for determining distance. True distance is the default.\i0\par
\par
// only functions\par
static int[][] generate(Vector<Coord> pointList, Coord size)\par
static int[][] generate(Vector<Coord> pointList, int sizeX, int sizeY)\par
static int[][] generate(Vector<Coord> pointList, Coord size, boolean distType)\par
static int[][] generate(Vector<Coord> pointList, int sizeX, int sizeY, boolean distType)\par
\i Returns a 2D array, where each element contains the index of the point to which it is closest.\i0\par
\par
\ul\b\fs28 WSConstants (interface)\ulnone\b0\fs24\par
\i Constants for WidlerSuite. Used by a variety of classes.\i0\par
\par
static final int RECT_MODE\par
static final int HEX_MODE\par
\i Mode flags, for classes that need to differentiate between rectangular mode and pseudo-hexagonal mode.\i0\par
\par
static final boolean SEARCH_DIAGONAL\par
static final boolean DONT_SEARCH_DIAGONAL\par
\i Mode flags for rect mode; whether or not diagonal stepping is legal.\i0\par
\par
// adjacency lists: x, y, stepCost\par
static final int[][] RECT_ORTHO\par
static final int[][] RECT_DIAG\par
static final int[][] HEX_EVEN_ROW\par
static final int[][] HEX_ODD_ROW\par
\i Lists of the offsets of adjacent tiles.\i0\par
\par
static final int NE, E, SE, SW, W, NW\par
\i Enumerators for hexagonal stuff.\i0\par
\par
static double GRAVITY\par
\i Acceleration due to gravity in tiles per tick per tick.\i0\par
\par
static int FRAMES_PER_SECOND \par
\i A bunch of stuff needs to know fps to properly display. Default is 30 fps.\i0\par
\par
final static double FULL_CIRCLE\par
final static double THREE_QUARTER_CIRCLE\par
final static double HALF_CIRCLE\par
final static double QUARTER_CIRCLE\par
final static double EIGHTH_CIRCLE\par
final static double SIXTH_CIRCLE\par
final static double TWELFTH_CIRCLE\par
\i Commonly used angles in radians, to avoid a bunch of unnecessary calculations.\i0\par
\par
\ul\b\fs28 WSTools (class)\ulnone\b0\fs24\par
Implements: WSConstants\par
\i A collection of utility functions which can be called statically. WSTools also contains a static random number generator, to centralize use.\i0\par
\par
static double random()\par
\i Returns a random number between 0.0 and 1.0 exclusive.\i0\par
\par
static int random(int n)\par
\i Returns a random positive integer from 0 to (n-1) inclusive.\i0\par
\par
static Color randomColor()\par
\i Returns a random color.\i0\par
\par
static int roundToInt(double value)\par
\i Rounds a double to an int.\i0\par
\par
static int roundToEven(double value)\par
\i Rounds to an intiger, but .5 rounds to the nearest even int.\i0\par
\par
static double simplifyAngle(double angle)\par
\i Removes full circles (including negative circles) from an angle.\i0\par
\par
static int minMax(int min, int value, int max)\par
\i Bounds an int by the passed values.\i0\par
\par
static double minMax(double min, double value, double max)\par
\i Bounds a double by the passed values.\i0\par
\par
static double pathDistance(Coord origin, Vector<Coord> path, double diagonalCost)\par
double pathDistance(Coord origin, Vector<Coord> path)\par
\i Returns the walking distance of a passed path. Assumes that the passed vector contains a sequential list of adjacent cells.\i0\par
\par
static String doubleToPercent(double d)\par
\i Returns a string representing a double as a (integer) percentage. Ex: .346 returns "34%".\i0\par
\par
static int getAngbandMetric(Coord start, Coord end)\par
static int getAngbandMetric(int startX, int startY, int endX, int endY)\par
\i Returns all the long axis plus half the short axis.\i0\par
\par
static int getDistanceMetric(Coord start, Coord end)\par
static int getDistanceMetric(int startX, int startY, int endX, int endY)\par
\i Returns the square of the hypotenuse; used for quickly calculating which of several distances is longer and you don't care what the actual distance is.\i0\par
\par
static double getDistance(Coord start, Coord end)\par
static double getDistance(int startX, int startY, int endX, int endY)\par
\i Returns the actual distance between two points.\i0\par
\par
static double interpolateLinear(float p1, float p2, float xOff)\par
\i Returns the value of a point between two values.  For example, if the passed values are 2 and 4, and the xOffset is .5 (halfway between the two), this will return 3.\i0\par
\par
static double interpolateCosine(float p1, float p2, float xOff)\par
\i Returns a value similar to interpolateLinear(), but on an s-curve so that results are more heavily weighted towards the closer of the two points.\i0\par
\par
static double getRatio(int cur, int max)\par
static double getRatio(double cur, double max)\par
\i Returns the the fractional portion of max which cur is as a double.\i0\par
\par
static Coord getHexIndex(double x, double y)\par
static Coord getHexIndex(double x, double y, boolean roundToEven)\par
\i Returns the index of the tile in which the pixel lies, accounting for hex offset. x and y are in tiles.\i0\par
\par
static double getHexX(int rectX, int rectY)\par
static double getHexX(Coord c)\par
\i Returns the actual x position of a passed hex tile (every odd row is indented by .5 tiles).\i0\par
\par
static Coord[] getAdjacentHexes(int originX, int originY)\par
static Coord[] getAdjacentHexes(Coord origin)\par
\i Returns the indices of the six hexes adjacent to the passed location.\i0\par
\par
static double getAngle(double x, double y)\par
\i Returns the angle from 0, 0 to the passed point.\i0\par
\par
static Color[] getGradient(Color startColor, Color endColor, int steps)\par
\i Returns an array that smoothly transitions from startColor to endColor in a specific number of steps.\i0\par
\par
static Color[][] getBlit(int width, int height, BufferedImage src)\par
\i Copies a passed image into a color map of that is [width][height] in size.\i0\par
}
 