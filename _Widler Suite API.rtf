{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deftab709{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset0 Liberation Serif;}}
{\colortbl ;\red0\green0\blue0;\red0\green0\blue255;\red0\green0\blue128;}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\nowidctlpar\hyphpar0\qc\kerning1\b\f0\fs36\lang1033 Widler Suite API\b0\f1\fs24\par

\pard\nowidctlpar\hyphpar0\kerning0\f0\par
\kerning1 The Widler Suite is a set of tools primarily intended for roguelike programmers using Java. This document serves as the primary reference for the API. Many functions are overloaded; these share a single description in most cases. \f1\par
\kerning0\f0\par
\kerning1 Overwritten functions of interfaces and child classes are generally not described, even when public. If you need to overwrite any of these (things like ActionPerformed(ActionEvent) or paint(Graphics)), be sure to call super.functionName().\f1\par
\kerning0\f0\par
\kerning1 For a demonstration of many of the following classes and functions, please run WidlerSuiteDemo.jar.\f1\par
\kerning0\f0\par
\kerning1 Copyright Michael Widler, 2019. Permission granted for public or private use. No warranty of any kind is expressed or implied. If you use this suite in your project, please give credit. And let me know; I'd love to see this in use.\f1\par
\kerning0\f0\par
\par
\kerning1\ul\b\fs28 AStar (class)\ulnone\b0\f1\fs24\par
\f0 Implements: WSConstants\f1\par
\i\f0 AStar is an implementation of the A* algorithm for pathfinding. This implementation operates on a boolean map (true = passable, false = impassable). It is primarily intended to be called with path().\i0\f1\par
\kerning0\f0\par
\kerning1\i Note: AStar uses AStarNode and AStarOpenList, which should not be directly called by the application programmer during normal use. As such, they are not documented here.\i0\f1\par
\kerning0\f0\par
\kerning1 static int MAX_LOOPS\f1\par
\i\f0 Maximum loops the algorithm will take, to prevent wasting time if no path exists. Default value is 5000.\i0\f1\par
\kerning0\f0\par
\kerning1 static double HEURISTIC_MULTIPLER\f1\par
\i\f0 Used to tune the algorithm. Default value is 11.0.\i0\f1\par
\kerning0\f0\par
\kerning1 void setMode(int m)\f1\par
\i\f0 Sets the search mode (which cells are considered adjacent). Accepts WSTools. RECT_MODE or WSTools.HEX_MODE, and defaults to the former. Search mode is static; this function will affect all subsequent searches, and as such is not thread safe.\i0\f1\par
\kerning0\f0\par
\kerning1 void setSearchDiagonal(boolean sd)\f1\par
\i\f0 Sets whether diagonally adjacent cells are considered adjecent when in rect mode.\i0\f1\par
\kerning0\f0\par
\kerning1 AStar()\f1\par
\i\f0 Empty constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 Vector<Coord> path(boolean[][] pm, Coord start, Coord end)\f1\par
\cf1\f0 Vector<Coord> path(boolean[][] pm, int startX, int startY, int endX, int endY)\cf0\f1\par
\i\f0 Primary function. Attempts to make a path between start and end. Returns an empty vector if no such path exists, or if max iterations are performed.\i0\f1\par
\kerning0\f0\par
\kerning1 void setMap(boolean[][] pm)\f1\par
\i\f0 Makes a deep copy of a boolean map, and sets internal values accordingly.\i0\f1\par
\kerning0\f0\par
\kerning1 Vector<Coord> getPath(Coord origin, Coord terminus)\f1\par
\f0 Vector<Coord> getPath(int originX, int originY, int terminusX, int terminusY)\f1\par
\i\f0 Determine a path and return it. Only works on an AStar instance that already has its map set.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 AnimationManager (class)\ulnone\b0\f1\fs24\par
\f0 Implements: ActionListener\f1\par
\i\f0 This class does two things; it manages unbound strings for a RoguePanel, and has several static functions related to animation. Only the static functions are expected to be called, as each RoguePanel instantiates its own AnimationManager and interacts with it without user meddling. If being used as intended, there is no need for the application programmer to instantiate their own AnimationManager. For this reason, non-static public functions are not described here.\i0\f1\par
\kerning0\f0\par
\kerning1\i Note that AnimationManager receives actionPerformed calls from its parent RoguePanel; if you have non-timer ActionEvents being listened to by the RoguePanel, maybe you'll need to do something about that.\i0\f1\par
\kerning0\f0\par
\kerning1 static void pause()\f1\par
\i\f0 Pauses UmboundString processing, though not blinking nor pulsing.\i0\f1\par
\kerning0\f0\par
\kerning1 static void unpause()\f1\par
\i\f0 Unpauses UnboundString processing.\i0\f1\par
\kerning0\f0\par
\kerning1 static void setThrottle(int t)\f1\par
\i\f0 Ticks and pulses only increment every n ticks, where n = throttle\i0\f1\par
\kerning0\f0\par
\kerning1 static boolean slowBlink()\f1\par
\i\f0 Returns a boolean which alternates based on the timer hooked up to the parent RoguePanel. Default is 1 cycle per 60 ticks.\i0\f1\par
\kerning0\f0\par
\kerning1 static boolean mediumBlink()\f1\par
\i\f0 Returns a boolean which alternates based on the timer hooked up to the parent RoguePanel. Default is 1 cycle per 40 ticks.\i0\f1\par
\kerning0\f0\par
\kerning1 static boolean fastBlink()\f1\par
\i\f0 Returns a boolean which alternates based on the timer hooked up to the parent RoguePanel. Default is 1 cycle per 20 ticks.\i0\f1\par
\kerning0\f0\par
\kerning1 static int slowPulse()\f1\par
\i\f0 Returns an int which iterates based on the timer hooked up to the parent RoguePanel. Default is 0 to 20 to 0 inclusive, in steps of 1, at 1 step per tick.\i0\f1\par
\kerning0\f0\par
\kerning1 static int mediumPulse()\f1\par
\i\f0 Returns an int which iterates based on the timer hooked up to the parent RoguePanel. Default is 0 to 20 to 0 inclusive, in steps of 2, at 1 step per tick.\i0\f1\par
\kerning0\f0\par
\kerning1 static int fastPulse()\f1\par
\i\f0 Returns an int which iterates based on the timer hooked up to the parent RoguePanel. Default is 0 to 20 to 0 inclusive, in steps of 3, at 1 step per tick.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 BinarySpacePartitioning (static class)\ulnone\b0\f1\fs24\par
\i\f0 This class is entirely static. Its intended purpose is to execute binary space partitioning on an area defined by partition(). It returns a list of all rooms, not just the final rooms, with the first being representing the total space and each subsequent pair representing sibilings. Which is to say, every pair of rooms n and n+1, with n being odd and greater than zero, are adjacent. See full algorithm at {\lang255{\field{\*\fldinst{HYPERLINK http://roguebasin.roguelikedevelopment.org/index.php?title=Basic_BSP_Dungeon_generation }}{\fldrslt{http://roguebasin.roguelikedevelopment.org/index.php?title=Basic_BSP_Dungeon_generation\ul0\cf0}}}}\kerning0\i0\f0\fs24 . \kerning1\f1\par
\kerning0\f0\par
\kerning1 void setPartitionChance(double pc)\f1\par
\i\f0 Sets the chance that a room which is equal to or below maximum size will be further split, so long as the child rooms are still equal to or above minimum size.\i0\f1\par
\kerning0\f0\par
\kerning1 static Vector<Room> partition(int x, int y, int minRoomDiameter, int maxRoomDiameter)\f1\par
\f0 static Vector<Room> partition(Coord size, int minRoomDiameter, int maxRoomDiameter)\f1\par
\i\f0 The main function. x and y determine total size. maxRoomDiameter must be at least twice minRoomDiameter, or it will be raised to that value.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 BorderBuilder (static class)\ulnone\b0\f1\fs24\par
\kerning0\f0 The purpose of this class is to determine which box-drawing characters to use, given a TilePalette that conforms to cp437 and an array indicating which tiles should be border characters. There's a bunch of public static data members that are used internally, not listed here because there's no need. As this is obviously limited by the character set, it is entirely possible to provide input that generates output with jarring transitions.\kerning1\f1\par
\kerning0\f0\par
\kerning1 static int[][] getBorderTiles(int[][] origArr)\f1\par
\i\f0 Returns an array of the same dimensions as the passed array, where each index contains either 0, or the index value of the appropriate box-drawing character. The input array must be formatted where 1 represents a single-thickness border tile, and 2 represents a double-thickness border tile. All other values are ignored, and will translate to 0 in the output array.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 Coord (class)\ulnone\b0\f1\fs24\par
\i\f0 Coord is essentially a struct, with a bit more functionality. It is used to represent x-y pairs, such as Cartesian coordinates, height and width, etc. It has two public data members, x and y, and no other data. It is used fairly extensively throughout the Widler Suite.\i0\f1\par
\f0 int x, int y\f1\par
\i\f0 The two data members. Both are public.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord()\f1\par
\i\f0 Empty constructor. Default values are -1, -1.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord(int newX, int newY)\f1\par
\i\f0 Constructor using ints.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord(Coord that)\f1\par
\i\f0 Deep copy constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord(int[] that)\f1\par
\i\f0 Int array constructor. Chokes unless that[] has at least two members, and ignores anything beyond the first two.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord(Vect that)\f1\par
\i\f0 Converts polar to rectangular coordinates. See the Vect class, below.\i0\f1\par
\kerning0\f0\par
\kerning1 void copy(Coord that)\f1\par
\i\f0 Deep copies an existing Coord into this one.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord copy()\f1\par
\i\f0 Returns a deep copy of this object.\i0\f1\par
\kerning0\f0\par
\kerning1 void add(Coord that)\f1\par
\i\f0 Sums that Coord into this one (that is unchanged).\i0\f1\par
\kerning0\f0\par
\kerning1 void subtract(Coord that)\f1\par
\i\f0 Subtracts that Coord from this one (that is unchanged).\i0\f1\par
\kerning0\f0\par
\kerning1 void set(Vect that)\f1\par
\i\f0 Set this Coord by a Vect (converts mathematical vector to Cartesian coordinates).\i0\f1\par
\kerning0\f0\par
\kerning1 double distanceTo(Coord that)\f1\par
\i\f0 Return the distance between this Coord and another one.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean equals(Coord that)\f1\par
\i\f0 Checks if two Coords are structurally equal.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean equals(int w, int h)\f1\par
\i\f0 Checks if this Coord has identical data to the passed data.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isAdjacent(Coord that)\f1\par
\i\f0 Checks if this and that are adjacent (orthogonally or diagonally).\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isOrthogonallyAdjacent(Coord that)\f1\par
\i\f0 Checks if this and that are orthogonally adjacent.\i0\f1\par
\kerning0\f0\par
\kerning1 Vect getAsVect()\f1\par
\i\f0 Returns this Coord as a Vect (converts Cartesian coordinates to mathematical vector).\i0\f1\par
\kerning0\f0\par
\kerning1 double getMagnitude()\f1\par
\i\f0 Converts the xy coordinates to a mathematical vector, and returns just the magnitude.\i0\f1\par
\kerning0\f0\par
\kerning1 double getAngle()\f1\par
\i\f0 Converts the xy coordinates to a mathematical vector, and returns just the angle.\i0\f1\par
\kerning0\f0\par
\kerning1 double getAngleTo(Coord)\f1\par
\i\f0 Returns the angle from this Coord to the passed one.\i0\f1\par
\kerning0\f0\par
\kerning1 String toString()\f1\par
\i\f0 Returns a string representing the Coord, formatted as \ldblquote [x][y]\rdblquote .\i0\f1\par
\kerning0\f0\par
\kerning1 static void removeDuplicates(Vector<Coord> list)\f1\par
\i\f0 Traverses a (java.util.Vector, not WidlerSuite.Vect) of Coords and removes duplicates. This function modifies the Vector passed as an argument.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 CP437 (interface)\ulnone\b0\f1\fs24\par
\i\f0 This is an interface implementing the character set of code page 437. Primarily the UTF-8 characters are placed in a two-dimensional array of their CP437 locations, and many are given constants.\i0\f1\par
\kerning0\f0\par
\kerning1 static final char[][] CP437_TABLE\f1\par
\i\f0 A 16x16 table of the 256 characters.\i0\f1\par
\kerning0\f0\par
\kerning1\i Additionally, the following constants are also present, formatted for brevity. Constants do not represent the full array; in particular, box-drawing characters and characters which can be typed on a US keyboard.\i0\f1\par
\f0 static final char SMILE_NO_FILL_CHAR, SMILE_FILL_CHAR, HEART_CHAR, DIAMOND_CHAR, CLUB_CHAR, SPADE_CHAR, DOT_FILL_CHAR, DOT_FILL_COMPLEMENT_CHAR, DOT_NO_FILL_CHAR, DOT_NO_FILL_COMPLEMENT_CHAR, MALE_CHAR, FEMALE_CHAR, NOTE_CHAR, DOUBLE_NOTE_CHAR, SUN_CHAR, RIGHT_TRIANGLE_CHAR, LEFT_TRIANGLE_CHAR, DOUBLE_VERTICAL_ARROW_CHAR, DOUBLE_EXCLAMATION_CHAR, PARAGRAPH_CHAR, DOUBLE_S_CHAR, SMALL_BOX_CHAR, UP_ARROW_CHAR, DOWN_ARROW_CHAR, RIGHT_ARROW_CHAR, LEFT_ARROW_CHAR, DOUBLE_HORIZONTAL_CHAR, UP_TRIANGLE_CHAR, DOWN_TRIANGLE_CHAR, DELETE_CHAR, CENT_CHAR, GBP_CHAR, YEN_CHAR, PTS_CHAR, FUNCTION_CHAR, INVERTED_QUESTION_MARK_CHAR, ONE_HALF_CHAR, ONE_QUARTER_CHAR, INVERTED_EXCLAMATION_MARK_CHAR, DOUBLE_LEFT_ARROW_CHAR, DOUBLE_RIGHT_ARROW_CHAR, LIGHT_SHADE_CHAR, MEDIUM_SHADE_CHAR, DARK_SHADE_CHAR, FULL_BLOCK_CHAR, LOWER_HALF_BLOCK_CHAR, LEFT_HALF_BLOCK_CHAR, RIGHT_HALF_BLOCK_CHAR, UPPER_HALF_BLOCK_CHAR, ALPHA_CHAR, BETA_CHAR, GAMMA_CHAR, PI_CHAR, CAPITAL_SIGMA_CHAR, SMALL_SIGMA_CHAR, MU_CHAR, TAU_CHAR, CAPITAL_PHI_CHAR, THETA_CHAR, OMEGA_CHAR, DELTA_CHAR, INFINITY_CHAR, SMALL_PHI_CHAR, EPSILON_CHAR, INTERSECTION_CHAR, TRIPLE_BAR_CHAR, PLUS_MINUS_CHAR, GTE_CHAR, LTE_CHAR, INTEGRAL_TOP_CHAR, INTEGRAL_BOTTOM_CHAR, DIVISION_CHAR, ALMOST_EQUAL_CHAR, DEGREE_CHAR, BULLET_CHAR, MIDDLE_DOT_CHAR, SQRT_CHAR, SUPERSCRIPT_N_CHAR, SUPERSCRIPT_2_CHAR, BLACK_SQUARE_CHAR, EMPTY_CHAR\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 DijkstraMap (class)\ulnone\b0\f1\fs24\par
\f0 Implements: WSConstants\f1\par
\i\f0 Creates an int Dijkstra map of a passed boolean area, using any number of goals; calculates the distance from nearest goal. The expected use is that the application programmer will call the constructor, set goals as necessary, call process() or partiallyProcess(), then use the generated data as needed.\i0\f1\par
\kerning0\f0\par
\kerning1\i The default value of a cell is 1,000,000. As distances are kept in decisteps (10 decisteps = 1 actual step), if your mapping requires maps large enough that 100,000 steps is a valid data point, you're gonna get weirdness. And performance issues, most likely.\i0\f1\par
\kerning0\f0\par
\kerning1\i Having a large number of goals increases the execution time by n. Having a large area increases the execution time by n^2.\i0\f1\par
\kerning0\f0\par
\kerning1\i An implementation of the idea found at: http:  {\i0\f1{\field{\*\fldinst{HYPERLINK "http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps" }}{\fldrslt{\ul\cf2\cf3\ul\i\f0\lang255 www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps}}}}\kerning0\i0\f0\fs24  \kerning1\f1\par
\f0  \f1\par
\f0 DijkstraMap(boolean[][] pm)\f1\par
\i\f0 The constructor. Takes a pass map (false cells will be ignored during processing; that is, the algorithm goes around them).\i0\f1\par
\kerning0\f0\par
\kerning1 void addGoal(Coord c)\f1\par
\f0 void addGoal(int x, int y)\f1\par
\i\f0 Add a goal to the list. Goals are the thing that the algorithm determines distance from.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean[][] getPassMap()\f1\par
\i\f0 Returns a reference to the passability map. This is not a copy.\i0\f1\par
\kerning0\f0\par
\kerning1 int[][] getMap()\f1\par
\i\f0 Returns the Dijkstra map. Cell values are decisteps from nearest goal.\i0\f1\par
\kerning0\f0\par
\kerning1 Vector<Coord> getGoalList()\f1\par
\i\f0 Returns a reference to the list of goals. This is not a copy.\i0\f1\par
\kerning0\f0\par
\kerning1 void setPassMap(boolean[][] p)\f1\par
\i\f0 Sets the passability map. Doesn't error check, so if the new map's size is different than the last one, make a new instance of this class instead.\i0\f1\par
\kerning0\f0\par
\kerning1 void setGoalList(Vector<Coord> g)\f1\par
\i\f0 Overwrites the goal list with the passed one.\i0\f1\par
\kerning0\f0\par
\kerning1 void setMode(int m)\f1\par
\i\f0 Sets the diagonal mode (either WSConstants.RECT_MODE or WSConstants.HEX_MODE). Default behavior is rectangular grid.\i0\f1\par
\kerning0\f0\par
\kerning1 void setSearchDiagonal(boolean d)\f1\par
\i\f0 Sets whether, when in rect mode, the algorithm can step diagonally. Default behavior is true.\i0\f1\par
\kerning0\f0\par
\kerning1 void clearGoalList()\f1\par
\i\f0 Clears the list of goals.\i0\f1\par
\kerning0\f0\par
\kerning1 int getValue(Coord c)\f1\par
\f0 int getValue(int x, int y)\f1\par
\i\f0 Returns the value of the passed cell of the output map. Returns the default cell value (1,000,000) for out-of-bounds cells.\i0\f1\par
\kerning0\f0\par
\kerning1 int getStepValue(Coord c)\f1\par
\f0 int getStepValue(int x, int y)\f1\par
\i\f0 Returns the value of the passed cell of the output map, converted to steps. Returns the default cell value (100,000 steps) for out-of-bounds cells.\i0\f1\par
\kerning0\f0\par
\kerning1 Vector<Coord> getLowestAdjacent(Coord c)\f1\par
\f0 Vector<Coord> getLowestAdjacent(int xLoc, int yLoc)\f1\par
\i\f0 Returns a list of all cells that share the lowest adjacent value.\i0\f1\par
\kerning0\f0\par
\kerning1 Vector<Coord> getHighestAdjacent(Coord c)\f1\par
\f0 Vector<Coord> getHighestAdjacent(int xLoc, int yLoc)\f1\par
\i\f0 Returns a list of all cells that share the highest adjacent value.\i0\f1\par
\kerning0\f0\par
\kerning1 void resetMap()\f1\par
\i\f0 Readies the output map for another search, without changing the passability map.\i0\f1\par
\kerning0\f0\par
\kerning1 void process()\f1\par
\i\f0 Processes the entire output map. Clears it first, so you don't need to call resetMap().\i0\f1\par
\kerning0\f0\par
\kerning1 void partiallyProcess(int startX, int startY, int endX, int endY)\f1\par
\f0 void partiallyProcess(int startX, int startY, int endX, int endY, boolean mapIsSet)\f1\par
\i\f0 Processes part of the map (which can be all of it). Only clears the output map (all of it) if mapIsSet == false. Passed locations are inclusive.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 DijkstraRing (class)\ulnone\b0\f1\fs24\par
\i\f0 Calculates concentric rings using a Dijkstra map. Generated on first call, and always considers diagonals valid.\i0\f1\par
\f0  \f1\par
\f0 static Vector<Coord> getRing(int radius)\f1\par
\i\f0 Returns a list of Coords in a set radius around [0,0]\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 DoubleDeck (class)\ulnone\b0\f1\fs24\par
\i\f0 An implementation for bagging; give it a range of doubles, tell it how many copies of each you want, and it makes a shuffled deck of them to be popped one at a time. The internal RNG is initially seeded with a pseudo-random number.\i0\f1\par
\kerning0\f0\par
\kerning1 DoubleDeck(double[] values, int copies)\f1\par
\i\f0 Constructor for a shuffled deck of doubles, with a number of copies of each value equal to the passed argument.\i0\f1\par
\f0  \f1\par
\f0 DoubleDeck(double[] values)\f1\par
\i\f0 Constructor for a shuffled deck of doubles, with one copy of each passed value. Note that there is no duplicate checking; if you have n copies of a given value in the passed array, you will have n copies in the deck.\i0\f1\par
\kerning0\f0\par
\kerning1 void shuffle(int seed)\f1\par
\i\f0 Set the RNG seed and shuffle the deck. Shuffling returns all popped values to the deck.\i0\f1\par
\kerning0\f0\par
\kerning1 void shuffle()\f1\par
\i\f0 Reshuffle the the deck. Shuffling returns all popped values to the deck.\i0\f1\par
\kerning0\f0\par
\kerning1 double pop()\f1\par
\i\f0 Pop the top value off the deck. If called on an empty deck, it will reshuffle first.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 FloodFill (class)\ulnone\b0\f1\fs24\par
\f0 Implements WSConstants\f1\par
\i\f0 An of a flood fill algorithm, intended to be used statically. Accepts a boolean array and starting location; false is impassable, true is passable. Returns a boolean array of the same size, where true is filled and false is not. Not thread safe (will collide with self).\i0\f1\par
\kerning0\f0\par
\kerning1 static boolean[][] fill(boolean area[][], int x, int y)\f1\par
\f0 static boolean[][] fill(boolean area[][], Coord loc)\f1\par
\i\f0 Primary method. Returns a boolean array where true is filled, and false is what was not.\i0\f1\par
\kerning0\f0\par
\kerning1 static boolean isInBounds(int x, int y)\f1\par
\i\f0 Checks if the passed tile location is in the display bounds.\i0\f1\par
\kerning0\f0\par
\kerning1 static void invertMap(boolean[][] map)\f1\par
\i\f0 Not necessary, but often useful.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 FontLoader (class)\ulnone\b0\f1\fs24\par
\i\f0 A class for loading fonts, with some helper functions for checking size.\i0\f1\par
\kerning0\f0\par
\kerning1 static String load(String fontFileName)\f1\par
\i\f0 Loads the named font file (excluding the file extension) which must be a truetype font. Returns the system name of the font is successful, or null if unsuccessful.\i0\f1\par
\kerning0\f0\par
\kerning1 static int getCharWidth(String fontName, int pointSize)\f1\par
\i\f0 Returns the pixel width of the widest character in the passed font.\i0\f1\par
\kerning0\f0\par
\kerning1 static int getCharHeight(String fontName, int pointSize)\f1\par
\i\f0 Returns the pixel height of the tallest character in the passed font.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 HexLine (class)\ulnone\b0\f1\fs24\par
\f0 Extends: StraightLine\f1\par
\i\f0 Creates a straight line between two points on a hex grid. I'll be super honest here; this one's got a dirty workaround in it. The only good solution I came up with involves handling the coordinates in an entirely different manner, and then it clashes with the rest of the suite. So it works fine, but if anyone has a cleaner solution shoot me an email.\i0\f1\par
\kerning0\f0\par
\kerning1\i Can be called directly or throught StraightLine, when StraightLine is in Hex Mode. Static.\i0\f1\par
\kerning0\f0\par
\kerning1 static Vector<Coord> findLine(Coord tileOrigin, Coord tileTarget)\f1\par
\f0 static Vector<Coord> findLine(Coord tileOrigin, Coord tileTarget, int arguments)\f1\par
\i\f0 Returns the line between two points, subject to arguments.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 LayoutPanel (class)\ulnone\b0\f1\fs24\par
\f0 Extends: JPanel\f1\par
\i\f0 A panel which manages the layout (size and location) of child panels passed with that info. Size and locations are kept as proportions of this panel; for example, if a component is added with x = 0.0, y=0.5, h = 0.5, w = 0.5, it would occupy the bottom left quarter of this panel.\i0\f1\par
\kerning0\f0\par
\kerning1\i Automatically resizes component when parent frame is resized.\i0\f1\par
\kerning0\f0\par
LayoutPanel(JFrame pf)\kerning1\f1\par
\kerning0\i\f0 Main constructor. Requires a parent frame (the jFrame in which this sits).\kerning1\i0\f1\par
\kerning0\f0\par
void add(Component c, double w, double h, double x, double y)\kerning1\f1\par
\kerning0\i\f0 Adds a new component, which is sized to w width and h height, as a portion of this panel, and position x, y of this panel, also as proportions. Expected ranges for these numbers are [0.0, 1.0].\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 void resizeComponents()\kerning1\f1\par
\kerning0\f0 void resizeComponents(boolean repaint)\kerning1\f1\par
\kerning0\i\f0 Recalculates size and placement of components. Automatically called if parent component is resized. Default behavior is repaint = true.\kerning1\i0\f1\par
\kerning0\f0\par
void setValues(Component c, double w, double h, double x, double y)\kerning1\f1\par
\kerning0\i\f0 Set values of an already added component.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 void remove(Component c)\kerning1\f1\par
\i\f0 Remove an already added component.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 LineIntersection (static class)\ulnone\b0\f1\fs24\par
\i\f0 A static class that checks if two line segments intersect. Adapted from code by Princi Singh, which can be found at {\lang255{\field{\*\fldinst{HYPERLINK https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/ }}{\fldrslt{https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\ul0\cf0}}}}\kerning0\i0\f0\fs24 .\kerning1\f1\par
\kerning0\f0\par
boolean isIntersecting(Coord p1, Coord q1, Coord p2, Coord q2)\kerning1\f1\par
\kerning0\f0 boolean isIntersecting(int[] p1, int[] q1, int[] p2, int[] q2)\kerning1\f1\par
\kerning0\i\f0 Checks if line segments [p1, q1] and [p2, q2] instersect.\kerning1\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 LuhnsChecksum (static class)\ulnone\b0\f1\fs24\par
\i\f0 A static class that generates and validates checksums for strings. An adaptation of Luhn's Algorithm.\i0\f1\par
\kerning0\f0\par
String appendChecksum(String str)\kerning1\f1\par
\kerning0\i\f0 Generates the checksum character for the passed string and returns a string with that character appended.\kerning1\i0\f1\par
\kerning0\f0\par
char genChecksum(String str)\kerning1\f1\par
\i\f0 Generates the checksum character for the passed string.\i0\f1\par
\kerning0\f0\par
boolean validate(String str)\kerning1\f1\par
\i\f0 Indicates whether the last character in the passed string is the correct checksum for the rest of that string.\i0\f1\par
\kerning0\f0\par
\par
\kerning1\ul\b\fs28 MovementScript (class)\ulnone\b0\f1\fs24\par
\f0 Implements: ActionListener\f1\par
\i\f0 Contains a list of steps (changes in position) and impulses (changes in speed) to be applied to an UnboundString target (or child class). Passed to a RoguePanel with RoguePanel.add(), which then passes it off to the appropriate manager. Steps are executed once per tick.\i0\f1\par
\kerning0\f0\par
\kerning1\i Instances of MovementScript are kicked before their targets are, and do not kick their targets; targets should still be on either the locking or nonlocking list.\i0\f1\par
\kerning0\f0\par
\kerning1\i Note: MovementScript uses MovementScriptStep, which should not be directly called by the application programmer during normal use. As such, it is not documented here.\i0\f1\par
\kerning0\f0\par
\kerning1 MovementScript(UnboundString us)\f1\par
\i\f0 Constructor. Takes the target UnboundString as an argument.\i0\f1\par
\kerning0\f0\par
\kerning1 UnboundString getTarget()\f1\par
\i\f0 Returns the target UnboundString.\i0\f1\par
\kerning0\f0\par
\kerning1 Vector<MovementScriptStep> getStepList()\f1\par
\i\f0 Returns a list of the MovementScriptSteps to be executed (full list, regardless of where it is in that execution).\i0\f1\par
\kerning0\f0\par
\kerning1 boolean loops()\f1\par
\i\f0 Returns whether this script loops upon completion.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean expiresTargetOnEnd()\f1\par
\i\f0 Returns whether or not this script manually expires its target upon completion.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean nonlocksTargetOnEnd()\f1\par
\i\f0 Returns whether or not this script moves its target from the locking list to the non-locking list upon expiration..\i0\f1\par
\kerning0\f0\par
\kerning1 int length()\f1\par
\i\f0 Returns the number of steps/ticks in the script.\i0\f1\par
\kerning0\f0\par
\kerning1 void setTarget(UnboundString t)\f1\par
\i\f0 Set the target.\i0\f1\par
\kerning0\f0\par
\kerning1 void setStepList(Vector<MovementScriptStep> s)\f1\par
\i\f0 Set the steps.\i0\f1\par
\kerning0\f0\par
\kerning1 void setLoops(boolean l)\f1\par
\i\f0 Set whether or not the script loops.\i0\f1\par
\kerning0\f0\par
\kerning1 void setExpiresTargetOnEnd(boolean e)\f1\par
\i\f0 Set whether or not the script manually expires its target.\i0\f1\par
\kerning0\f0\par
\kerning1 void setNonlocksTargetOnEnd(boolean e)\f1\par
\i\f0 Set whether or not the script moves its target from the locking list to the non-locking list upon expiration.\i0\f1\par
\kerning0\f0\par
\kerning1 void setExpired(boolean e)\f1\par
\i\f0 Manually sets whether this script is expired.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isExpired()\f1\par
\i\f0 Checks if the script is expired.\i0\f1\par
\kerning0\f0\par
\kerning1 void setLength(int newLength)\f1\par
\i\f0 Set the length of the script, in ticks.\i0\f1\par
\kerning0\f0\par
\kerning1 void setImpulse(int tickIndex, double newXImpulse, double newYImpulse)\f1\par
\i\f0 Set the impulse at a particular time. Will extend the script if passed tick does not exist.\i0\f1\par
\kerning0\f0\par
\kerning1 void setOffset(int tickIndex, double newXOffsetAdj, double newYOffsetAdj)\f1\par
\i\f0 Set the impulse at a particular time. Will extend the script if passed tick does not exist.\i0\f1\par
\kerning0\f0\par
\kerning1 void setStep(int tickIndex, double newXImpulse, double newYImpulse, double newXOffsetAdj, double newYOffsetAdj)\f1\par
\i\f0 Set both the impulse and step at a particular time. Will extend the script if passed tick does not exist.\i0\f1\par
\kerning0\f0\par
\kerning1 void setStep(int tickIndex, MovementScriptStep newStep)\f1\par
\i\f0 Copy a step into the script.\i0\f1\par
\kerning0\f0\par
\kerning1 void clearStep(int tickIndex)\f1\par
\i\f0 Clear a particular step.\i0\f1\par
\kerning0\f0\par
\kerning1 void actionPerformed(ActionEvent ae)\f1\par
\i\f0 Interface for ActionEvents. You shouldn't need to mess with this one.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 NoiseChoir (class)\ulnone\b0\f1\fs24\par
\i\f0 A class for layering multiple levels (octaves) of NoiseObjs. The user can control how many layers\i0\f1\par
\i\f0 are present, how much each layer weighs comparatively (persistence), and how much each layer\i0\f1\par
\i\f0 changes in frequency (inversely, the distance between samples).\i0\f1\par
\kerning0\f0\par
\kerning1\i Calls are done the same as for a NoiseObj; by calling getValue(double, double).\i0\f1\par
\kerning0\f0\par
\kerning1 static int DEFAULT_OCTAVES\f1\par
\i\f0 Default number of octaves (layers of noise). Defaults to 4.\i0\f1\par
\kerning0\f0\par
\kerning1 static double DEFAULT_PERSISTENCE \f1\par
\i\f0 Default level of persistence, which is the multiplicative amount a layer is weighted. In standard use should be in the range of (0, 1), so that successive layers have less weight. Defaults to .5 (each level is half as important as the previous).\i0\f1\par
\kerning0\f0\par
\kerning1 static double DEFAULT_FREQUENCY_MULTIPLIER\f1\par
\i\f0 How much the frequency is increased for each level. The space between each sample point is the reciprocal of frequency. Defaults to .5 (each level of noise is twice as large and sampled twice as wide as the previous).\i0\f1\par
\kerning0\f0\par
\kerning1 NoiseObj[] getNoise()\f1\par
\i\f0 Returns the array of NoiseObjs.\i0\f1\par
\kerning0\f0\par
\kerning1 int getOctaves()\f1\par
\i\f0 Returns the current number of octaves.\i0\f1\par
\kerning0\f0\par
\kerning1 double getPersistence()\f1\par
\i\f0 Returns the current level of persistence.\i0\f1\par
\kerning0\f0\par
\kerning1 void setNoise(NoiseObj[] n)\f1\par
\i\f0 Sets the octave array with a shallow copy.\i0\f1\par
\kerning0\f0\par
\kerning1 void setOctaves(int o)\f1\par
\i\f0 Sets the number of octaves (does not automatically call generate()).\i0\f1\par
\kerning0\f0\par
\kerning1 void setPersistence(double p)\f1\par
\i\f0 Sets the level of persistence (does not automatically call generate()).\i0\f1\par
\kerning0\f0\par
\kerning1 NoiseChoir()\f1\par
\i\f0 Default constructor, runs with default values (automatically calls generate()).\i0\f1\par
\kerning0\f0\par
\kerning1 NoiseChoir(int oct)\f1\par
\i\f0 Constructor specifying number of octaves (automatically calls generate()).\i0\f1\par
\kerning0\f0\par
\kerning1 NoiseChoir(int oct, double pers)\f1\par
\i\f0 Constructor specifying number of octaves and persistence (automatically calls generate()).\i0\f1\par
\kerning0\f0\par
\kerning1 NoiseChoir(int oct, double pers, double freqMult)\f1\par
\i\f0 Constructor specifying all the variables (automatically calls generate()).\i0\f1\par
\kerning0\f0\par
\kerning1 void generate()\f1\par
\i\f0 Sets the values for each NoiseObj.\i0\f1\par
\kerning0\f0\par
\kerning1 double getValue(double xOff, double yOff)\f1\par
\i\f0 Calculates and returns the value of a point. This is the one you'll call a lot.\i0\f1\par
\kerning0\f0\par
\kerning1 double applyBillow(double amt)\f1\par
\f0 double applyBillow()\f1\par
\i\f0 Create a billowing effect by folding the low-valued vertices of each NoiseObj back over themselves.\i0\f1\par
\kerning0\f0\par
\kerning1 double applyRidged(double amt)\f1\par
\f0 double applyRidged()\f1\par
\i\f0 Create a sharp ridged effect by raising the vertices of each NoiseObj to the power of amt.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 NoiseObj (class)\ulnone\b0\f1\fs24\par
\i\f0 A class for a Perlin-style noise, which automatically wraps. This generates a single octave \i0\f1\par
\i\f0 of noise; see NoiseChoir  for layering them together. An octave of noise is a 2D array of doubles, where each element is in the range of (0.0, 1.0). The idea is to call points that lie between the vertices, and the NoiseObj will then calculate the value of that point based on how close they are to the four surrounding vertices. This is either scaled linearly (which yields angles) or by cosine interpolation (which yields smooth curves).\i0\f1\par
\kerning0\f0\par
\kerning1\i Essentially after creation, call in intervals << 1.0 to get smooth (or linear, your call)\i0\f1\par
\i\f0 noise.\i0\f1\par
\kerning0\f0\par
\kerning1 static final int DEFAULT_DIAMETER\f1\par
\i\f0 Default size where the number of points stored is a 2D array.\i0\f1\par
\kerning0\f0\par
\kerning1 double[][] getVertexArr()\f1\par
\i\f0 Returns the entire vertex array.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isSmooth()\f1\par
\i\f0 Returns true if using cosine interpolation, or false if using linear interpolation.\i0\f1\par
\kerning0\f0\par
\kerning1 int getWidth()\f1\par
\i\f0 Returns the width (x-component) of the vertex array.\i0\f1\par
\kerning0\f0\par
\kerning1 int getHeight()\f1\par
\i\f0 Returns the height (y-component) of  the vertex array.\i0\f1\par
\kerning0\f0\par
\kerning1 void setVertexArr(double[][] v)\f1\par
\i\f0 Set the entire vertex array.\i0\f1\par
\kerning0\f0\par
\kerning1 void setSmooth(boolean s)\f1\par
\i\f0 Set the type if interpolation; smooth (true) or linear (false).\i0\f1\par
\kerning0\f0\par
\kerning1 NoiseObj()\f1\par
\i\f0 Default constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 NoiseObj(int width, int height)\f1\par
\i\f0 Constructs and populates a NoiseObj with set dimensions.\i0\f1\par
\kerning0\f0\par
\kerning1 void generate()\f1\par
\f0 void generate(int width, int height)\f1\par
\i\f0 Reset the array and regenerate values.\i0\f1\par
\kerning0\f0\par
\kerning1 double getValue(double xOff, double yOff)\f1\par
\i\f0 Calculates and returns the value of a point. This is the one you'll call a lot.\i0\f1\par
\kerning0\f0\par
\kerning1 double applyBillow(double amt)\f1\par
\f0 double applyBillow()\f1\par
\i\f0 Create a billowing effect by folding the low-valued vertices back over themselves.\i0\f1\par
\kerning0\f0\par
\kerning1 double applyRidged(double amt)\f1\par
\f0 double applyRidged()\f1\par
\i\f0 Create a sharp ridged effect by raising the vertices to the power of amt.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 Obfuscator (static class)\ulnone\b0\f1\fs24\par
\i\f0 Used to obfuscate and deobfuscate a string. Used to make things like save files non-human readable. Only mangles characters in the range of ' ' to '~' (ASCII/Unicode 32 -c 127 inclusive), to stay out of control characters. Static.\i0\f1\par
\kerning0\f0\par
\kerning1\i Note that you could use deobfuscate() to mangle and obfuscate() to then demangle, as we're just shifting sideways through the character range. Also if you obfuscate() n times, deobfuscating() n times gets you back the original.\i0\f1\par
\kerning0\f0\par
\kerning1 static String obfuscate(String str)\f1\par
\i\f0 Returns an obfuscated (wrapping right-shifted) copy of the passed string.\i0\f1\par
\kerning0\f0\par
\kerning1 static String deobfuscate(String str)\f1\par
\i\f0 Returns a deobfuscated (wrapping left-shifted) copy of the passed string.\i0\f1\par
\i\f0 .\i0\f1\par
\ul\b\f0\fs28 RectLine (class)\ulnone\b0\f1\fs24\par
\f0 Extends: StraightLine\f1\par
\i\f0 Creates a straight line between two points on a rectangular grid. This is an implementation of Bresenham's Line. Can be called directly or through StraightLine when StraightLine is in Rect Mode. Static.\i0\f1\par
\kerning0\f0\par
\kerning1 static Vector<Coord> findLine(Coord origin, Coord target)\f1\par
\f0 static Vector<Coord> findLine(Coord origin, Coord target, int arguments)\f1\par
\i\f0 Returns the line between two points, subject to arguments.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 RoguePanel (class)\ulnone\b0\f1\fs24\par
\f0 Extends JPanel \f1\par
\f0 Implements ComponentListener, ActionListener, MouseListener, MouseMotionListener, WSConstants\f1\par
\i\f0 A class for a curses implementation. Everything is pretty much handled internally, except for being hooked up to a timer (which is passed on to the unbound string stuff, as long as this panel is visible).\i0\f1\par
\kerning0\f0\par
\kerning1\i Internally, RoguePanel keeps three two-dimensional arrays; one for background color, one for foreground color, and one for foreground strings. Additionally, each instance has its own AnimationManager, for displaying UnboundStrings. Also, a RoguePanel has an out-of-bounds tile who's values are returned when the user attempts to get a tile that does not exist.\i0\f1\par
\kerning0\f0\par
\kerning1\i RoguePanel is not designed to be a map structure, which is to say that it does not hold data it does not intend to display (with a few exceptions). So it does not scroll through a large area, only displaying part of it; if that's how your map operates, the map should only pass down the part that is being used.\i0\f1\par
\kerning0\f0\par
\kerning1\i I thought of having an interface for map cells, but as most ASCII roguelikes seem to load the three values from the map, overwrite some with items, then overwrite some with actors, and then again possibly with visual effects, which is beyond the scope of this class, I decided against it.\i0\f1\par
\kerning0\f0\par
\kerning1\i Note getMouseColumn() and getMouseRow() are intended to be called when external mouseListeners and mouseMotionListeners recieve events, but whatever floats your goat.\i0\f1\par
\kerning0\f0\par
\kerning1 Font getFont()\f1\par
\i\f0 Returns a shallow copy of the current font for strings.\i0\f1\par
\kerning0\f0\par
\kerning1 String getFontName()\f1\par
\i\f0 Returns the proper name of the current font.\i0\f1\par
\kerning0\f0\par
\kerning1 Color getTileBorderColor()\f1\par
\i\f0 Returns the border color of each tile when showBorder is set to true.\i0\f1\par
\kerning0\f0\par
\kerning1 Color getOOBBGColor()\f1\par
\i\f0 Gets the color for the out-of-bounds tile background.\i0\f1\par
\kerning0\f0\par
\kerning1 Color getOOBFGColor()\f1\par
\i\f0 Gets the color for the out-of-bounds tile foreground.\i0\f1\par
\kerning0\f0\par
\kerning1 String getOOBBGString()\f1\par
\i\f0 Gets the string for the out-of-bounds tile.\i0\f1\par
\kerning0\f0\par
\kerning1 double getXScroll()\f1\par
\i\f0 Returns the current horizontal display displacement in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 double getYScroll()\f1\par
\i\f0 Returns the current vertical display displacement in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean getTrimOddAxis()\f1\par
\i\f0 Returns whether the last tile of odd rows will be shown in hex mode.\i0\f1\par
\kerning0\f0\par
\kerning1 int columns()\f1\par
\i\f0 Returns the number of columns to be displayed.\i0\f1\par
\kerning0\f0\par
\kerning1 int rows()\f1\par
\i\f0 Returns the number of rows to be displayed.\i0\f1\par
\kerning0\f0\par
\kerning1 int mouseColumn()\f1\par
\i\f0 Returns the index of the column in which the mouse is currently located, or -1 if the mouse is not in a column.\i0\f1\par
\kerning0\f0\par
\kerning1 int mouseRow()\f1\par
\i\f0 Returns the index of the row in which the mouse is currently located, or -1 if the mouse is not in a row.\i0\f1\par
\kerning0\f0\par
\kerning1 void setFontName(String f)\f1\par
\i\f0 Sets the font based on the name string passed in.\i0\f1\par
\kerning0\f0\par
\kerning1 void showTileBorders(boolean sb)\f1\par
\i\f0 Set whether each tile has a border.\i0\f1\par
\kerning0\f0\par
\kerning1 void setTileBorderColor(Color bc)\f1\par
\i\f0 Set the border color for each tile.\i0\f1\par
\kerning0\f0\par
\kerning1 void setOOBBGColor(Color c)\f1\par
\i\f0 Set the out-of-bounds tile's background color.\i0\f1\par
\kerning0\f0\par
\kerning1 void setOOBFGColor(Color c)\f1\par
\i\f0 Set the out-of-bounds tile's foreground color.\i0\f1\par
\kerning0\f0\par
\kerning1 void setOOBString(String s)\f1\par
\i\f0 Set the out-of-bounds tile's foreground string.\i0\f1\par
\kerning0\f0\par
\kerning1 void setScroll(double x, double y)\f1\par
\i\f0 Set display displacement (ignoring screen shake, padding, etc) in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setTrimOddAxis(boolean toa)\f1\par
\i\f0 Sets if the last tile of odd-numbered rows will be shown in hex mode.\i0\f1\par
\kerning0\f0\par
\kerning1 RoguePanel()\f1\par
\i\f0 Empty constructor. Defaults to 15x15.\i0\f1\par
\kerning0\f0\par
\kerning1 RoguePanel(int w, int h)\f1\par
\i\f0 Size-based constructor; creates a RoguePanel with w columns and h rows.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isInBounds(Coord loc)\f1\par
\f0 boolean isInBounds(int x, int y)\f1\par
\i\f0 Checks if the passed tile location is in the display bounds.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isShaking()\f1\par
\i\f0 Checks if the screen is currently shaking\i0\f1\par
\kerning0\f0\par
\kerning1 void randomize()\f1\par
\i\f0 Assigns random values to each cell. Mostly used for testing.\i0\f1\par
\kerning0\f0\par
\kerning1 void setAll(String s, Color fg, Color bg)\f1\par
\i\f0 Set all tiles to a specific set of variables.\i0\f1\par
\kerning0\f0\par
\kerning1 void setColumnsAndRows(Coord size)\f1\par
\f0 void setColumnsAndRows(int x, int y)\f1\par
\i\f0 Sets the RoguePanel to have x columns and y rows.\i0\f1\par
\kerning0\f0\par
\kerning1 void setFGColor(Coord loc, Color c)\f1\par
\f0 void setFGColor(int x, int y, Color c)\f1\par
\i\f0 Set foreground color of a specific tile.\i0\f1\par
\kerning0\f0\par
\kerning1 void setBGColor(Coord loc, Color c)\f1\par
\f0 void setBGColor(int x, int y, Color c)\f1\par
\i\f0 Set background color of a specific tile.\i0\f1\par
\kerning0\f0\par
\kerning1 void setString(Coord loc, String s)\f1\par
\f0 void setString(int x, int y, String s)\f1\par
\i\f0 Set the string (generally one character) of a specific tile.\i0\f1\par
\kerning0\f0\par
\kerning1 void setTile(Coord loc, String s, Color fg, Color bg)\f1\par
\f0 void setTile(int x, int y, String s, Color fg, Color bg)\f1\par
\i\f0 Set a tile's values all at once.\i0\f1\par
\kerning0\f0\par
\kerning1 void setTile(Coord loc, String s, Color fg)\f1\par
\f0 void setTile(int x, int y, String s, Color fg)\f1\par
\i\f0 Set a tile's foreground values all at once.\i0\f1\par
\kerning0\f0\par
\kerning1 void setDisplayMode(int dm)\f1\par
\i\f0 Set the display to either rect (orthoginal) or hex (diagonal), using constants from WSConstants.\i0\f1\par
\kerning0\f0\par
\kerning1 void setScreenShake(double radius, int duration)\f1\par
\f0 void setScreenShake(double radiusX, double radiusY, int duration)\f1\par
\i\f0 Set screen shake. Overwrites any existing screen shake. radius values are in tiles, duration is in ticks.\i0\f1\par
\kerning0\f0\par
\kerning1 void setBGBox(Coord loc, Coord size, Color c)\f1\par
\f0 void setBGBox(int x, int y, int w, int h, Color c)\f1\par
\i\f0 Set a rectangular area of backgrounds to a single color.\i0\f1\par
\kerning0\f0\par
\kerning1 void setFGBox(Coord loc, Coord size, Color c)\f1\par
\f0 void setFGBox(int x, int y, int w, int h, Color c)\f1\par
\i\f0 Set a rectangular area of foregrounds to a single color.\i0\f1\par
\kerning0\f0\par
\kerning1 void setFGBox(Coord loc, Coord size, String s, Color c)\f1\par
\f0 void setFGBox(int x, int y, int w, int h, String s, Color c)\f1\par
\i\f0 Set a rectangular area of the foreground to a single string and color.\i0\f1\par
\kerning0\f0\par
\kerning1 void write(Coord loc, String str, Color c)\f1\par
\f0 void write(int x, int y, String str, Color c)\f1\par
\i\f0 Write a string in sequential tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void writeBox(Coord loc, Coord box, String str, Color c)\f1\par
\f0 void writeBox(int xStart, int yStart, int w, int h, String str, Color c)\f1\par
\i\f0 Write a string inside an area, with word wrapping.\i0\f1\par
\kerning0\f0\par
\kerning1 Color getFGColor(Coord loc)\f1\par
\f0 Color getFGColor(int x, int y)\f1\par
\i\f0 Returns the foreground color of the passed location.\i0\f1\par
\kerning0\f0\par
\kerning1 Color getBGColor(Coord loc)\f1\par
\f0 Color getBGColor(int x, int y)\f1\par
\i\f0 Returns the background color of the passed location.\i0\f1\par
\kerning0\f0\par
\kerning1 String getString(Coord loc)\f1\par
\f0 String getString(int x, int y)\f1\par
\i\f0 Returns the string of the passed location.\i0\f1\par
\kerning0\f0\par
\kerning1 void addLocking(UnboundString us)\f1\par
\i\f0 Add a locking unbound string (passed to the animation manager). Locking UnboundStrings don't inherently do anything different that non-locking ones, but you can check if there are any with isAnimationLocked() to know to wait for animation to complete.\i0\f1\par
\kerning0\f0\par
\kerning1 void addNonlocking(UnboundString us)\f1\par
\f0 void add(UnboundString us)\f1\par
\i\f0 Add a non-locking unbound string (passed to the animation manager).\i0\f1\par
\kerning0\f0\par
\kerning1 void remove(UnboundString us)\f1\par
\i\f0 Removes the passed unbound string, if it is currently on the locking or non-locking list of the animation manager.\i0\f1\par
\kerning0\f0\par
\kerning1 void add(MovementScript ms)\f1\par
\i\f0 Adds the passed MovementScript to the animation manager.\i0\f1\par
\kerning0\f0\par
\kerning1 void remove(MovementScript ms)\f1\par
\i\f0 Removes the passed movement script, if it is currently on the script list of the animation manager.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isAnimationLocked()\f1\par
\i\f0 Check if external processes should be delayed while waiting for animation to complete.\i0\f1\par
\kerning0\f0\par
\kerning1 void clearUnboundStrings()\f1\par
\i\f0 Clear all the unbound string lists.\i0\f1\par
\kerning0\f0\par
\kerning1 void setCornerCell(Coord loc)\f1\par
\f0 void setCornerCell(int x, int y)\f1\par
\i\f0 Set the corner cell, for properly displaying unbound strings. The corner cell is the index of the upper rightmost displayed tile.\i0\f1\par
\kerning0\f0\par
\kerning1 void setCenterCell(Coord loc)\f1\par
\f0 void setCenterCell(int x, int y)\f1\par
\i\f0 Set the corner cell by passing the center cell.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 RogueTilePanel (class)\ulnone\b0\f1\fs24\par
\f0 Extends JPanel \f1\par
\f0 Implements ComponentListener, ActionListener, MouseListener, MouseMotionListener, WSConstants\f1\par
\i\f0 A tile-based implementation of RoguePanel. Everything is pretty much handled internally, except for being hooked up to a timer (which is passed on to the unbound string stuff, as long as this panel is visible).\i0\f1\par
\kerning0\f0\par
\kerning1\i Rather than dynamically drawing the elements like RoguePanel, RogueTilePanel uses a TilePalette to generate the images. Additionally, each instance has its own AnimationManager, for displaying UnboundTiles. Also, a RogueTilePanel has an out-of-bounds tile who's values are returned when the user attempts to get a tile that does not exist.\i0\f1\par
\kerning0\f0\par
\kerning1\i RogueTilePanel is not designed to be a map structure, which is to say that it does not hold data it does not intend to display (with a few exceptions). So it does not scroll through a large area, only displaying part of it; if that's how your map operates, the map should only pass down the part that is being used.\i0\f1\par
\kerning0\f0\par
RogueTilePanel(int w, int h, TilePalette p)\kerning1\f1\par
\kerning0\i\f0 Constructor. Takes width in tiles, height in tiles, and a TilePalette.\kerning1\i0\f1\par
\kerning0\f0\par
double getSizeMultiplier()\kerning1\f1\par
\kerning0\i\f0 Simple getter for the multiplication factor from the TilePalette to this panel.\kerning1\i0\f1\par
\kerning0\f0  \kerning1\f1\par
\kerning0\f0 double getXScroll()\kerning1\f1\par
\kerning0\i\f0 Get the current scroll value in tiles.\kerning1\i0\f1\par
\kerning0\f0\par
double getYScroll()\kerning1\f1\par
\kerning0\i\f0 Get the current scroll value in tiles.\kerning1\i0\f1\par
\kerning0\f0  \kerning1\f1\par
\kerning0\f0 double getXInset()\kerning1\f1\par
\kerning0\i\f0 Get the current horizontal drawing inset in pixels.\kerning1\i0\f1\par
\kerning0\f0\par
double getYInset()\kerning1\f1\par
\kerning0\i\f0 Get the current vertical drawing inset in pixels.\kerning1\i0\f1\par
\kerning0\f0  \kerning1\f1\par
\kerning0\f0 boolean isInBounds(Coord loc)\kerning1\f1\par
\kerning0\f0 boolean isInBounds(int x, int y)\kerning1\f1\par
\kerning0\i\f0 Checks if the passed tile location is in the tile boundaries of this panel.\kerning1\i0\f1\par
\kerning0\f0   \kerning1\f1\par
\kerning0\f0 int getFGColor(Coord c)\kerning1\f1\par
\kerning0\f0 int getFGColor(int x, int y)\kerning1\f1\par
\kerning0\i\f0 Returns the foreground color of the passed tile, or the foreground of the OOB tile if out of bounds.\kerning1\i0\f1\par
\kerning0\f0\par
int getBGColor(Coord c)\kerning1\f1\par
\kerning0\f0 int getBGColor(int x, int y)\kerning1\f1\par
\kerning0\i\f0 Returns the background color of the passed tile, or the background of the OOB tile if out of bounds.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 int getIcon(Coord c)\kerning1\f1\par
\kerning0\f0 int getIcon(int x, int y)\kerning1\f1\par
\kerning0\i\f0 Returns the icon index of the passed tile, or the icon index of the OOB tile if out of bounds.\kerning1\i0\f1\par
\kerning0\f0\par
boolean isShaking()\kerning1\f1\par
\kerning0\i\f0 Returns if the panel is currently shaking.\kerning1\i0\f1\par
\kerning0\f0\par
void drawLockListFirst()\kerning1\f1\par
\kerning0\i\f0 Set panel to draw the locking unbound tiles before the non-locking ones.\kerning1\i0\f1\par
\kerning0\f0\par
void drawNonlockListFirst()\kerning1\f1\par
\kerning0\i\f0 Set panel to draw the non-locking unbound tiles before the locking ones. This is the default behavior.\kerning1\i0\f1\par
\kerning0\f0\par
void setSizeMultiplier(int sm)\kerning1\f1\par
\kerning0\i\f0 Simple setter. Sets the multiplication factor for the TilePalette.\kerning1\i0\f1\par
\kerning0\f0\par
void setScroll(double x, double y)\kerning1\f1\par
\kerning0\i\f0 Sets the current scrolling (visual offset) in tiles.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 void setTile(Coord c, int tileIndex, int fg, int bg)\kerning1\f1\par
\kerning0\f0 void setTile(int x, int y, int tileIndex, int fg, int bg)\kerning1\f1\par
\kerning0\i\f0 Set the tile of the passed location, using RGB values.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 void setCornerTile(Coord c)\kerning1\f1\par
\kerning0\f0 void setCornerTile(int x, int y)\kerning1\f1\par
\kerning0\i\f0 Sets what tile UnboundTiles consider to be the upper leftmost for drawing purposes. Used for scrolling maps. Ignore if your map does not scroll.\kerning1\i0\f1\par
\kerning0\f0\par
void setTile(Coord c, int tileIndex, Color fg, Color bg)\kerning1\f1\par
\kerning0\f0 void setTile(int x, int y, int tileIndex, Color fg, Color bg)\kerning1\f1\par
\kerning0\i\f0 Set the tile of the passed location, using colors.\kerning1\i0\f1\par
\kerning0\f0\par
void setFGColor(Coord c, int fg)\kerning1\f1\par
\kerning0\f0 void setFGColor(int x, int y, int fg)\kerning1\f1\par
\kerning0\i\f0 Set the foreground color of the passed tile.\kerning1\i0\f1\par
\kerning0\f0\par
void setBGColor(Coord c, int fg)\kerning1\f1\par
\kerning0\f0 void setBGColor(int x, int y, int fg)\kerning1\f1\par
\kerning0\i\f0 Set the background color of the passed tile.\kerning1\i0\f1\par
\kerning0\f0\par
void setIcon(Coord c, int tileIndex)\kerning1\f1\par
\kerning0\f0 void setIcon(int x, int y, int tileIndex)\kerning1\f1\par
\kerning0\i\f0 Set the icon of the passed tile by index.\kerning1\i0\f1\par
\kerning0\f0\par
void setAll(int i, int fg, int bg)\kerning1\f1\par
\kerning0\i\f0 Set all tiles to the passed values.\kerning1\i0\f1\par
\kerning0\f0\par
void setOOBTile(int index, int fg, int bg)\kerning1\f1\par
\kerning0\i\f0 Set the values of the out-of-bounds tile using RGB values.\kerning1\i0\f1\par
\kerning0\f0\par
void setOOBTile(int index, Color fg, Color bg)\kerning1\f1\par
\kerning0\i\f0 Set the values of the out-of-bounds tile using colors.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 void write(Coord loc, String s, Coord box)\kerning1\f1\par
\kerning0\f0 void write(int x, int y, String s, int w, int h)\kerning1\f1\par
\kerning0\i\f0 Write the passed string, at the passed location, with line wrapping on spaces and observance of \\n.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 void write(Coord loc, String s, int fgColor, int bgColor, Coord box)\kerning1\f1\par
\kerning0\f0 void write(int x, int y, String s, int fgColor, int bgColor, int w, int h)\kerning1\f1\par
\kerning0\i\f0 As write(int, int, String, int, int), but also setting foreground and background colors.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 void setWordColors(String word, int fgColor, int bgColor, Coord origin, Coord size, boolean findAll)\kerning1\f1\par
\kerning0\f0 void setWordColors(String word, int fgColor, int bgColor, int x, int y, int w, int h, boolean findAll)\kerning1\f1\par
\kerning0\i\f0 Sets the foreground and background colors of tilesequences matching the passed word to the passed arguments. Recognizes words wrapped over a line. If findAll is false, only finds the first instance, otherwise finds all instances in the passed box from [x, y] to [x+w, y+h].\kerning1\i0\f1\par
\kerning0\f0\par
void setScreenShake(double radius, int duration)\kerning1\f1\par
\kerning0\f0 void setScreenShake(double radiusX, double radiusY, int duration)\kerning1\f1\par
\kerning0\i\f0 Set screen shake. Overwrites any current screen shake. Radii are in tiles.\kerning1\i0\f1\par
\kerning0\f0\par
int getTileWidth()\kerning1\f1\par
\kerning0\i\f0 Returns tile width in pixels.\kerning1\i0\f1\par
\kerning0\f0\par
int getTileHeight()\kerning1\f1\par
\kerning0\i\f0 Returns tile height in pixels.\kerning1\i0\f1\par
\kerning0\f0\par
void addLocking(UnboundTile us)\kerning1\f1\par
\kerning0\i\f0 Add a locking UnboundTile. Locking UnboundTiles don't inherently do anything different that non-locking ones, but you can check if there are any with isAnimationLocked() to know to wait for animation to complete.\kerning1\i0\f1\par
\kerning0\f0\par
void addNonlocking(UnboundTile us)\kerning1\f1\par
\kerning0\f0 void add(UnboundTile us)\kerning1\f1\par
\kerning0\i\f0 Add a non-locking UnboundTile\kerning1\i0\f1\par
\kerning0\f0\par
void remove(UnboundTile us)\kerning1\f1\par
\kerning0\i\f0 Remove an UnboundTile\kerning1\i0\f1\par
\kerning0\f0\par
public void add(MovementScript scr)\kerning1\f1\par
\kerning0\i\f0 Add a Movement Script\kerning1\i0\f1\par
\kerning0\f0\par
void remove(MovementScript ms)\kerning1\f1\par
\kerning0\i\f0 Remove a movement script.\kerning1\i0\f1\par
\kerning0\f0\par
boolean isAnimationLocked()\kerning1\f1\par
\kerning0\i\f0 Returns true if there are any locking UnboundTiles.\kerning1\i0\f1\par
\kerning0\f0\par
void clearUnboundTiles()\kerning1\f1\par
\kerning0\i\f0 Clear all UnboundTiles.\kerning1\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 Room (class)\ulnone\b0\f1\fs24\par
\i\f0 A class used by the BSP generator. Keeps track of abstract rooms. Child rooms are made by splitting a single parent room. More or less a struct.\i0\f1\par
\i\f0 Modeled after the algorithm at: {\lang255{\field{\*\fldinst{HYPERLINK http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation }}{\fldrslt{http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation\ul0\cf0}}}}\i0\f1\fs24\par
\kerning0\f0\par
\par
\kerning1 Coord origin\f1\par
\i\f0 xy coordinate of the upper left corner of the room.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord size\f1\par
\i\f0 Width (x) and height (y) of the room.\i0\f1\par
\kerning0\f0\par
\kerning1 int iteration\f1\par
\i\f0 How many split iterations it took to create this room.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isParent\f1\par
\i\f0 True if any child rooms been made out of this one.\i0\f1\par
\kerning0\f0\par
\kerning1 Room()\f1\par
\i\f0 Empty constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean contains(Coord loc)\f1\par
\f0 boolean contains(int x, int y)\f1\par
\i\f0 Checks if the room contains the passed location.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isParentOf(Room that)\f1\par
\i\f0 Checks if this room is the parent of the passed room, strictly by checking iterations.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord getCenter()\f1\par
\i\f0 Returns a Coord corresponding to the center of this room.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean equals(Room that)\f1\par
\i\f0 Checks if two rooms are equivalent (have equal origins and sizes).\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isHorizontallyAdjacent(Room that)\f1\par
\f0 boolean isHorizontallyAdjacent(Room that, boolean findSibiling)\f1\par
\i\f0 Returns true if the right boundary of this room and the left boundary of that room are in adjacent columns. If findSibiling is true, then checks the opposite as well (right of that adjacent to left of this).\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isVerticallyAdjacent(Room that)\f1\par
\f0 boolean isVerticallyAdjacent(Room that, boolean findSibiling)\f1\par
\i\f0 Returns true if the bottom boundary of this room and the top boundary of that room are in adjacent columns. If findSibiling is true, then checks the opposite as well (bottom of that adjacent to top of this).\i0\f1\par
\kerning0\f0\par
\kerning1 Coord getRandomCell()\f1\par
\i\f0 Returns a random location within the room.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 ShadowFoV (abstract class)\ulnone\b0\f1\fs24\par
\f0 Implements: WSConstants\f1\par
\i\f0 Abstract parent class for ShadowFoVHex and ShadowFoVRect. Reduces code duplication, ensures consistent interface, allow objects to be unaware of what kind of FoV they're using.\i0\f1\par
\kerning0\f0\par
\kerning1 ShadowFoV(boolean[][] transpMap)\f1\par
\i\f0 Constructor. Requires a boolean map where true is transparent, and false blocks line of sight. This is held as a shallow copy, so changes to the original will be carried over.\i0\f1\par
\kerning0\f0\par
\kerning1 void reset(boolean[][] transpMap)\f1\par
\i\f0 Changes the transparency map. Again, this is a shallow copy and this function generally only needs to be called if an entirely different transparency map is needed.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isInBounds(int x, int y)\f1\par
\f0 boolean isInBounds(Coord loc)\f1\par
\i\f0 Checks if the passed location is inside the map bounds.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean blocksLoS(int x, int y)\f1\par
\f0 boolean blocksLoS(Coord loc)\f1\par
\i\f0 Checks if a square blocks LoS.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isVisible(int x, int y)\f1\par
\f0 boolean isVisible(Coord loc)\f1\par
\i\f0 Checks if a square is visible, based on the last calcFoV call.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean[][] getArray(int startX, int startY, int w, int h)\f1\par
\i\f0 Returns a deep copy of the visibility array, bounded by the passed constraints.\i0\f1\par
\kerning0\f0\par
\kerning1 abstract void calcFoV(int xLoc, int yLoc, int radius)\f1\par
\i\f0 This is the main method to implement in child classes.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 ShadowFoVHex (class)\ulnone\b0\f1\fs24\par
\f0 Extends: ShadowFoV\f1\par
\i\f0 An implementation of shadowcasting FoV for hex modes. Checks if the center of a tile has LoS to at least one of six points on the target tile. Does not need to be reset in between runs. Because ShadowFoVRect (below) calculates field-of-view with octants, it has the capability to quickly determine LoS between two tiles by only calculating one octant. It appears to work for hex layouts too.\i0\f1\par
\kerning0\f0\par
\kerning1\i Basic procedure:\i0\f1\par
\i\f0    The cell's neighbors are added to the process list (checking if in bounds, in range and\i0\f1\par
\i\f0       not already added for each)\i0\f1\par
\i\f0    If a cell is in shadow, it is skipped\i0\f1\par
\i\f0    The cell is marked as visible\i0\f1\par
\i\f0    If the cell is not transparent, it registers a shadow.\i0\f1\par
\kerning0\f0\par
\kerning1\i Shadows:\i0\f1\par
\i\f0 A shadow is two angles; anything entirely occluded by shadows cannot be seen. Some tiles are occluded by multiple shadows (that is, no shadow covers all six points, but all six points are in shadow). As tiles are searched in an outward spiraling pattern, it is not necessary to note a shadow's starting point.\i0\f1\par
\kerning0\f0\par
\kerning1 ShadowFoVHex(boolean[][] transpMap)\f1\par
\i\f0 Basic constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 void set(boolean[][] transpMap)\f1\par
\i\f0 Prepares the arrays to be run; does not need to be called between runs unless the map changes.\i0\f1\par
\kerning0\f0\par
\kerning1 void calcFoV(int xLoc, int yLoc, int radius)\f1\par
\i\f0 Calculate lit squares from a given location and radius.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 ShadowFoVRect (class)\ulnone\b0\f1\fs24\par
\f0 Extends: ShadowFoV\f1\par
\i\f0 An implementation of a shadow casting FoV algorithm. This is my translation of Bj\'f6rn Bergstr\'f6m's Python implementation. Made to be persistent; just call calcFoV() with a new origin, or after updating the transparency map.\i0\f1\par
\kerning0\f0\par
\kerning1\i To be honest, while I understand the idea, the actual implementation is a little dense for me. Don't ask me to pick this one apart for you.\i0\f1\par
\kerning0\f0\par
\kerning1\i Description:\i0\f1\par
{\i\f0\lang255{\field{\*\fldinst{HYPERLINK http://roguebasin.roguelikedevelopment.org/index.php?title=FOV_using_recursive_shadowcasting }}{\fldrslt{http://roguebasin.roguelikedevelopment.org/index.php?title=FOV_using_recursive_shadowcasting\ul0\cf0}}}}\kerning0\f0\fs24  \kerning1\f1\par
\kerning0\f0\par
\kerning1\i Original Implementation:\i0\f1\par
{\i\f0\lang255{\field{\*\fldinst{HYPERLINK http://roguebasin.roguelikedevelopment.org/index.php?title=PythonShadowcastingImplementation }}{\fldrslt{http://roguebasin.roguelikedevelopment.org/index.php?title=PythonShadowcastingImplementation\ul0\cf0}}}}\f1\fs24\par
\kerning0\f0\par
\kerning1 ShadowFoVRect(boolean[][] transpMap)\f1\par
\i\f0 Basic constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 void calcFoV(int xLoc, int yLoc, int radius)\f1\par
\i\f0 Calculate visible squares from a given location and radius.\i0\f1\par
\kerning0\f0\par
\kerning1 void calcCone(int originX, int originY, int radius, targetX, targetY)\f1\par
\f0 void calcCone(Coord origin, int radius, Coord target)\f1\par
\i\f0 Calculate visible squares from a given location and radius, only in the octant containing the target cell. Note that while ShadowFoVHex doesn't have these functions, using ShadowFoVRect seems to work fine for that, as far as testing shows.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 SmoothCA (class)\ulnone\b0\f1\fs24\par
\f0 Implements: WSConstants\f1\par
\i\f0 A smoothing cellular automata class. Iterates over a copy of a 2D boolean array, making each cell more like its neighbors. The original boolean map is not modified.\i0\f1\par
\i\f0     \i0\f1\par
\i\f0 In rect mode, a tile is set to false if 5 of the 9 tiles in the 3x3 area centered on it are false, else it is set to true.\i0\f1\par
\i\f0     \i0\f1\par
\i\f0 In hex mode, a tile is set to false if 4 of the 7 tiles made up of itself and all adjacent tiles are false, else it is set to true.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean[][] getMap()\f1\par
\i\f0 Returns a shallow copy of the current map. Running process() replaces the map, rather than modifying it, but if you call getMap(), tweak the data, then call process(), your changes will carry over to the new map.\i0\f1\par
\kerning0\f0\par
\kerning1 SmoothCA(boolean[][] searchableMap)\f1\par
\f0 SmoothCA(boolean[][] searchableMap, int tileMode)\f1\par
\i\f0 Basic constructors. tileMode refers to WSConstants.HEX_MODE and WSConstants.RECT_MODE (rect is the default). Calling the constructor also runs process() once.\i0\f1\par
\kerning0\f0\par
\kerning1 static boolean[][] smooth(boolean[][] bm)\f1\par
\f0 static boolean[][] smooth(boolean[][] bm, int iterations)\f1\par
\f0 static boolean[][] smooth(boolean[][] bm, int iterations, int tileMode)\f1\par
\i\f0 A static method for when the object is unnecessary.\i0\f1\par
\kerning0\f0\par
\kerning1 void process()\f1\par
\i\f0 Runs a single iteration of smoothing.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 SpiralSearch (class)\ulnone\b0\f1\fs24\par
\f0 Implements: WSConstants\f1\par
\i\f0 After calling the constructor, each call to getNext() returns the next Coord in an increasing spiral. Part of calling the constructor is defining what tiles can be searched; unsearchable tiles also block the search (that is, this is a step-by-step flood fill).\i0\f1\par
\kerning0\f0\par
\kerning1\i getNext() returns null if no tiles remain to be searched.\i0\f1\par
\kerning0\f0\par
\kerning1\i The intended use is to find something that may or may not exist, when a location isn't known, or when you want to find the closest instance of a particular thing.\i0\f1\par
\kerning0\f0\par
\kerning1\i The algorithm only processes a couple tiles ahead of where getNext() is to maintain performance and limit unnecessary memory usage.\i0\f1\par
\kerning0\f0\par
\kerning1 SpiralSearch(boolean area[][], int startX, int startY, int tileMode, boolean diag)\f1\par
\f0 SpiralSearch(boolean area[][], Coord startLoc, int tileMode, boolean diag)\f1\par
\f0 SpiralSearch(boolean area[][], Coord startLoc)\f1\par
\f0 SpiralSearch(boolean area[][], int startX, int startY)\f1\par
\i\f0 Various constructors. Default behavior is diagonal searching = true, tileMode = rect.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord getNext()\f1\par
\i\f0 Returns the next Coord in the queue, and does a bit more searching if needed.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 SquirrelRNG (class)\ulnone\b0\f1\fs24\par
\i\f0 A random number generator that is very small, very fast, supports both random and sequential access. Very heavily based on a GDC talk by Squirrel Eiserloh. Individual threads should be given their own instances.\i0\f1\par
\kerning0\f0\par
\kerning1\i Instances maintain a position in the effectively infinite list of values; sampling returns the current value, next returns the same value and increments the position. Treating the list as a 2D structure does not increment position (it can only be sampled).\i0\f1\par
\kerning0\f0\par
\kerning1 SquirrelRNG(int seed)\f1\par
\i\f0 Constructor for seeded instantiation.\i0\f1\par
\f0    \f1\par
\f0 SquirrelRNG()\f1\par
\i\f0 Constructor that seeds the generator with a pseudo-random number.\i0\f1\par
\f0    \f1\par
\f0 void setSeed(int s)\f1\par
\i\f0 Set the seed.\i0\f1\par
\f0    \f1\par
\f0 int sampleInt(int position, int seed)\f1\par
\i\f0 Set the seed and return the int at the current position. Does not increment position.\i0\f1\par
\f0    \f1\par
\f0 double nextDouble()\f1\par
\i\f0 Take the next double and increment position.\i0\f1\par
\f0    \f1\par
\f0 int nextInt()\f1\par
\i\f0 Take the next int and increment position.\i0\f1\par
\f0    \f1\par
\f0 double sampleDouble(int position)\f1\par
\i\f0 Returns the double at the given position.\i0\f1\par
\f0    \f1\par
\f0 int sampleInt(int position)\f1\par
\i\f0 Returns the integer value at the given position.\i0\f1\par
\f0    \f1\par
\f0 int sample2DInt(int x, int y)\f1\par
\i\f0 Returns the integer at the given x,y position.\i0\f1\par
\f0    \f1\par
\f0 double sample2DDouble(int x, int y)\f1\par
\i\f0 Returns the double at the x,y position.\i0\f1\par
\f0    \f1\par
\f0 sample2DInt(int x, int y, int seed)\f1\par
\i\f0 Seeds the generator and then returns the integer at the given position.\i0\f1\par
\f0    \f1\par
\f0 sample2DDouble(int x, int y, int seed)\f1\par
\i\f0 Seeds the generator and then returns the double at the given position.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 StraightLine (class)\ulnone\b0\f1\fs24\par
\f0 Implements: WSConstants\f1\par
\i\f0 Used for calculating a list of tiles which lie on a line, this class calls down to the appropropriate child class (rect or hex), and holds the shared functions those two children need.\i0\f1\par
\kerning0\f0\par
\kerning1\i HexLine and RectLine can also be called directly, if preferred.\i0\f1\par
\kerning0\f0\par
\kerning1 static final int REMOVE_ORIGIN\f1\par
\f0 static final int REMOVE_TARGET\f1\par
\f0 static final int REMOVE_ORIGIN_AND_TARGET\f1\par
\i\f0 Final static variables for trimming ends.\i0\f1\par
\kerning0\f0\par
\kerning1 static void setRoundToEven(boolean r)\f1\par
\i\f0 Set whether lines will round normally, or round to even ints. Default is to round to even (this makes line a to b the same as line b to a).\i0\f1\par
\kerning0\f0\par
\kerning1 static void setMode(int m)\f1\par
\i\f0 Set the mode to either WSConstants.RECT_MODE or WSConstants.HEX_MODE. Default is rect.\i0\f1\par
\kerning0\f0\par
\kerning1 static Vector<Coord> findLine(Coord origin, Coord target)\f1\par
\f0 static Vector<Coord> findLine(Coord origin, Coord target, int arguments)\f1\par
\i\f0 Returns the line between two points, subject to arguments.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 TileAnimationManager (class)\ulnone\b0\f1\fs24\par
\f0 Implements: ActionListener\f1\par
\i\f0 TileAnimationManager is identical to AnimationManager, except that instead of dealing with RoguePanels and UnboundStrings, it deals with RogueTilePanels and UnboundTiles, respectively. See the entry for AnimationManager above.\i0\f1\par
\kerning0\f0\par
\kerning1\i Note that functions like AnimationManager.pause() do not affect TileAnimationManager, and vice versa. Blinking functions also may be slightly out of synch; use one or the other.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 TilePalette (class)\ulnone\b0\f1\fs24\par
\i\f0 A class for holding an image to use as a tile palette for classes like TileRoguePanel.  Loads from an image or image file. The image is partitioned into indexed subimages, which are then referred to by either their x,y positions, or by a single number representing its position on a list (read left to right, top to bottom).\i0\f1\par
\kerning0\f0\par
TilePalette(String fileName, int w, int t)\kerning1\f1\par
\kerning0\i\f0 Constructor to create a TilePalette from an image file, a number of tiles wide and tall.\kerning1\i0\f1\par
\kerning0\f0\par
TilePalette(BufferedImage image, int w, int t)\kerning1\f1\par
\kerning0\i\f0 Constructor to create a TilePalette from a BufferedImage, a number of tiles wide and tall (tiles, not pixels).\kerning1\i0\f1\par
\kerning0\f0\par
int getImageWidth()\kerning1\f1\par
\kerning0\i\f0 Returns the width of the entire palette, in pixels.\kerning1\i0\f1\par
\kerning0\f0\par
int getImageHeight()\kerning1\f1\par
\kerning0\i\f0 Returns the height of the entire palette, in pixels.\kerning1\i0\f1\par
\kerning0\f0\par
int getRows()\kerning1\f1\par
\kerning0\i\f0 Return the number of rows tall the palette is.\kerning1\i0\f1\par
\kerning0\f0\par
int getColumns()\kerning1\f1\par
\kerning0\i\f0 Return the number of columns wide the palette is.\kerning1\i0\f1\par
\kerning0\f0\par
int getTileWidth()\kerning1\f1\par
\kerning0\i\f0 Returns the width of a single tile, in pixels.\kerning1\i0\f1\par
\kerning0\f0\par
int getTileHeight()\kerning1\f1\par
\kerning0\i\f0 Returns the height of a single tile, in pixels.\kerning1\i0\f1\par
\par
\kerning0\f0 void setScaleMethodFast()\kerning1\f1\par
\kerning0\i\f0 Sets the scaling algorithm used by magnify() to prioritize speed.\kerning1\i0\f1\par
\par
\kerning0\f0 void setScaleMethodSmooth()\kerning1\f1\par
\kerning0\i\f0 Sets the scaling algorithm used by magnify() to prioritize smoothness.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 void loadFromFile(String fileName, int w, int t)\kerning1\f1\par
\kerning0\i\f0 Set the palette from a file, a number of tiles wide and tall (tiles, not pixels).\kerning1\i0\f1\par
\kerning0\f0\par
void loadFromBufferedImage(BufferedImage rawImage, int w, int t)\kerning1\f1\par
\kerning0\i\f0 Set the palette from a BufferedImage, a number of tiles wide and tall (tiles, not pixels).\kerning1\i0\f1\par
\kerning0\f0\par
int flatten(int x, int y)\kerning1\f1\par
\kerning0\i\f0 Turn 2d coordinates into an index value.\kerning1\i0\f1\par
\kerning0\f0\par
BufferedImage getTile(int i)\kerning1\f1\par
\kerning0\f0 BufferedImage getTile(int x, int y)\kerning1\f1\par
\kerning0\i\f0 Get the tile at the passed location.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 BufferedImage getTile(int i, Color fg, Color bg)\kerning1\f1\par
\kerning0\f0 BufferedImage getTile(int x, int y, Color fg, Color bg)\kerning1\f1\par
\kerning0\i\f0 Get a copy of the indexed tile in the specified colors, indicated by RGB values.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 BufferedImage getTile(int i, int fg, int bg)\kerning1\f1\par
\kerning0\f0 BufferedImage getTile(int x, int y, int fg, int bg)\kerning1\f1\par
\kerning0\i\f0 Get a copy of the indexed tile in the specified colors, indicated by color.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 BufferedImage magnify(BufferedImage img, int m)\kerning1\f1\par
\kerning0\i\f0 Return a copy of the image, scaled up by a factor of m.\kerning1\i0\f1\par
\kerning0\f0    \kerning1\f1\par
\kerning0\f0 UnboundTile getUnboundTile(int tileIndex, int fgColor, int bgColor, int sizeMultiplier, boolean bgType)\kerning1\f1\par
\kerning0\i\f0 Get a new UnboundTile of the specified values.\kerning1\i0\f1\par
\kerning0\f0\par
UnboundTile getUnboundTile(int tileIndex, int fgColor, int sizeMultiplier)\kerning1\f1\par
\kerning0\i\f0 Get a new UnboundTile with a transparent background.\kerning1\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 UnboundInterface (interface)\ulnone\b0\f1\fs24\par
\i\f0 An interface to aid in interchangeability between UnboundStrings, UnboundTiles, and any similar thing I wind up doing in the future. Values are in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void adjustXSpeed(double s)\f1\par
\f0 void adjustYSpeed(double s)\f1\par
\f0 void adjustXOffset(double p)\f1\par
\f0 void adjustYOffset(double p)\f1\par
\f0 void forceExpire()\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 UnboundString (class)\ulnone\b0\f1\fs24\par
\f0 Implements: ActionListener, WSConstants, UnboundInterface\f1\par
\i\f0 A class representing strings (and possibly a simple background behind the string) which are not bound to the RoguePanel's standard display grid. They have a defined lifespan, measured in ticks, and are removed when they expire.\i0\f1\par
\kerning0\f0\par
\kerning1 static final Color TRANSPARENT_BLACK\f1\par
\i\f0 Transparent black is a good background color for UnboundStrings, so it's part of the class.\i0\f1\par
\kerning0\f0\par
\kerning1 static final boolean GRAVITY_DEFAULT\f1\par
\i\f0 Whether or not UnboundStrings are affected by gravity by default. Defaults to false.\i0\f1\par
\kerning0\f0\par
\kerning1 static final int ROUNDED_RECT\f1\par
\f0 static final int RECT\f1\par
\f0 static final int OVAL\f1\par
\f0 static final int CIRCLE\f1\par
\i\f0 A group of signals for setting the type of background box.\i0\f1\par
\kerning0\f0\par
\kerning1 Color getBGColor()\f1\par
\i\f0 Returns the color of the background box.\i0\f1\par
\kerning0\f0\par
\kerning1 Color getFGColor()\f1\par
\i\f0 Returns the color of the string.\i0\f1\par
\kerning0\f0\par
\kerning1 String getString()\f1\par
\i\f0 Returns the string.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord getLoc()\f1\par
\i\f0 Returns the location, in tiles, of the UnboundString.\i0\f1\par
\kerning0\f0\par
\kerning1 int getXLoc()\f1\par
\i\f0 Returns the x location, in tiles, of the UnboundString.\i0\f1\par
\kerning0\f0\par
\kerning1 int getYLoc()\f1\par
\i\f0 Returns the y location, in tiles, of the UnboundString.\i0\f1\par
\kerning0\f0\par
\kerning1 double getXOffset()\f1\par
\i\f0 Returns the offset, in tiles, from the base x location.\i0\f1\par
\kerning0\f0\par
\kerning1 double getYOffset()\f1\par
\i\f0 Returns the offset, in tiles, from the base y location.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean hasBackgroundBox()\f1\par
\i\f0 Returns whether or not the UnboundString is displayed in front of a background box.\i0\f1\par
\kerning0\f0\par
\kerning1 int getBackgroundBoxType()\f1\par
\i\f0 Returns the type of background box, matching ROUNDED_RECT, RECT, OVAL, or CIRCLE.\i0\f1\par
\kerning0\f0\par
\kerning1 static int getDefaultLifespan()\f1\par
\i\f0 Returns the default lifespan, in ticks, of UnboundStrings.\i0\f1\par
\kerning0\f0\par
\kerning1 static void setDefaultLifespan(int dl)\f1\par
\i\f0 Set the default lifespan of new UnboundStrings.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isAffectedByGravity()\f1\par
\i\f0 Returns whether or not this particular UnboundString is affected by gravity.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isAffectedByAge()\f1\par
\i\f0 Returns whether or not this particular UnboundString is affected by age, and thus will expire normally.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isVisible()\f1\par
\i\f0 Returns whether or not this particular UnboundString should be drawn.\i0\f1\par
\kerning0\f0\par
\kerning1 void setBGColor(Color b)\f1\par
\i\f0 Sets the background box color.\i0\f1\par
\kerning0\f0\par
\kerning1 void setFGColor(Color f)\f1\par
\i\f0 Sets the foreground color.\i0\f1\par
\kerning0\f0\par
\kerning1 void setString(String s)\f1\par
\i\f0 Sets the foreground string.\i0\f1\par
\kerning0\f0\par
\kerning1 void setLoc(int x, int y)\f1\par
\f0 void setLoc(Coord l)\f1\par
\i\f0 Sets the location, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setXLoc(int x)\f1\par
\i\f0 Sets the x location, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setYLoc(int y)\f1\par
\i\f0 Sets the y location, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setXOffset(double x)\f1\par
\i\f0 Sets the x offset, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setYOffset(double y)\f1\par
\i\f0 Sets the y offset, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setBackgroundBox(boolean b)\f1\par
\i\f0 Sets whether or not a background is shown behind the string.\i0\f1\par
\kerning0\f0\par
\kerning1 void setBackgroundBoxType(int bt)\f1\par
\i\f0 Sets the type of background box.\i0\f1\par
\kerning0\f0\par
\kerning1 void setLifespan(int l)\f1\par
\i\f0 Sets the maximum lifespan, in ticks.\i0\f1\par
\kerning0\f0\par
\kerning1 void setAge(int a)\f1\par
\i\f0 Sets the current age. Once age == lifespan, the UnboundString expires.\i0\f1\par
\kerning0\f0\par
\kerning1 void setAffectedByGravity(boolean abg)\f1\par
\i\f0 Set whether or not this UnboundString is affected by gravity.\i0\f1\par
\kerning0\f0\par
\kerning1 void setAffectedByAge(boolean aba)\f1\par
\i\f0 Set whether or not this UnboundString is affected by age.\i0\f1\par
\kerning0\f0\par
\par
\kerning1 void setVisible(boolean v)\f1\par
\i\f0 Set whether or not this UnboundString should be displayed. Non-visible objects will still be kicked by the animation manager.\i0\f1\par
\kerning0\f0\par
\kerning1 UnboundString(String s)\f1\par
\i\f0 Basic constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 UnboundString(String s, Color fg, Coord l)\f1\par
\f0 UnboundString(String s, Color fg, int x, int y)\f1\par
\i\f0 Setting constructors.\i0\f1\par
\kerning0\f0\par
\kerning1 UnboundString(UnboundString that)\f1\par
\i\f0 Copy constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isExpired()\f1\par
\i\f0 Checks if an UnboundString should be removed by the manager.\i0\f1\par
\kerning0\f0\par
\kerning1 void forceExpire()\f1\par
\i\f0 Causes an UnboundString, even one not affected by age, to expire.\i0\f1\par
\kerning0\f0\par
\kerning1 void setSpeed(double x, double y)\f1\par
\i\f0 How many tiles are moved each tick. By default, UnboundStrings are stationary.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 UnboundTile (class)\ulnone\b0\f1\fs24\par
\f0 Implements: ActionListener, UnboundInterface\f1\par
\i\f0 A class representing a tile (and possibly a simple background behind the tile) which are not bound to the RogueTilePanel's standard display grid. They have a defined lifespan, measured in ticks, and are removed when they expire.\i0\f1\par
\i\f0\par
An UnboundTile may be assigned an anchor tile; another UnboundTile, from which the original's position is calculated, rather than the corner of the screen.\i0\f1\par
\kerning0\f0\par
\kerning1 static final boolean BOX_BACKGROUND\f1\par
\f0 static final boolean CIRCLE_BACKGROUND\f1\par
\kerning0\f0\par
\kerning1 UnboundTile(TilePalette pp)\f1\par
\i\f0 Basic constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 int getXLoc()\f1\par
\i\f0 Returns the x position of this tile in tiles, adjusted by the anchor tile (if it has one).\i0\f1\par
\kerning0\f0\par
\kerning1 int getYLoc()\f1\par
\i\f0 Returns the y position of this tile in tiles, adjusted by the anchor tile (if it has one).\i0\f1\par
\kerning0\f0\par
\kerning1 double getXOffset()\f1\par
\i\f0 Returns the x offset of this tile in tiles, adjusted by the anchor tile (if it has one).\i0\f1\par
\kerning0\f0\par
\kerning1 double getYOffset()\f1\par
\i\f0 Returns the y offset of this tile in tiles, adjusted by the anchor tile (if it has one).\i0\f1\par
\kerning0\f0\par
\kerning1 int getTrueXLoc()\f1\par
\i\f0 Returns the x position of this tile in tiles, ignoring any anchor tile.\i0\f1\par
\kerning0\f0\par
\kerning1 int getTrueYLoc()\f1\par
\i\f0 Returns the y position of this tile in tiles, ignoring any anchor tile.\i0\f1\par
\kerning0\f0\par
\kerning1 double getTrueXOffset()\f1\par
\i\f0 Returns the x offset of this tile in tiles, ignoring any anchor tile.\i0\f1\par
\kerning0\f0\par
\kerning1 double getTrueYOffset()\f1\par
\i\f0 Returns the y offset of this tile in tiles, ignoring any anchor tile.\i0\f1\par
\kerning0\f0\par
\kerning1 void setAnchorTile(UnboundTile at)\f1\par
\i\f0 Sets the passed UnboundTile as this tile's anchor tile. This UnboundTile's position will be calculated relative to the anchor tile's position, rather than relative to the corner of the screen.\i0\f1\par
\kerning0\f0\par
\kerning1 UnboundTile getAnchorTile()\f1\par
\i\f0 Returns a reference to this tile's anchor tile, or null if there is none.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean hasAnchorTile()\f1\par
\i\f0 Returns true if this tile has an anchor tile, else false.\i0\f1\par
\kerning0\f0\par
\kerning1 int getBGColor()\f1\par
\i\f0 Returns the RGB value of the background color of this tile.\i0\f1\par
\kerning0\f0\par
\kerning1 int getFGColor()\f1\par
\i\f0 Returns the RGB value of the foreground color of this tile.\i0\f1\par
\kerning0\f0\par
\kerning1 int getIconIndex()\f1\par
\i\f0 Returns the index of the icon of this tile.\i0\f1\par
\kerning0\f0\par
\kerning1 BufferedImage getImage()\f1\par
\i\f0 Returns a shallow copy of the tile's image.\i0\f1\par
\kerning0\f0\par
\kerning1 TilePalette getParentPalette()\f1\par
\i\f0 Returns the TilePalette being used by this tile.\i0\f1\par
\kerning0\f0\par
\kerning1 double getSizeMultiplier()\f1\par
\i\f0 Returns the size multiplier of this tile.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean getBGType()\f1\par
\i\f0 Returns the background type (BOX_BACKGROUND or CIRCLE_BACKGROUND) being used by this tile. \i0\f1\par
\kerning0\f0\par
\kerning1 double getGravity()\f1\par
\i\f0 Returns the acceleration due to gravity of this tile. This is independent of whether or not the tile is affected by gravity. Usually a negative number, in tiles per tick.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isAffectedByAge()\f1\par
\i\f0 Returns true is this tile has a maximum age.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isVisible()\f1\par
\i\f0 Returns true if this tile should be drawn.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isAffectedByGravity()\f1\par
\i\f0 Returns true if this tile is affected by gravity.\i0\f1\par
\kerning0\f0\par
\kerning1 double getTerminalVelocity()\f1\par
\i\f0 Returns the minimum y speed of this tile, if affected by gravity, in tiles per tick. Note that by minimum, I mean \ldblquote largest negative y value.\rdblquote\i0\f1\par
\kerning0\f0\par
\kerning1 void setXLoc(int x)\f1\par
\i\f0 Set the x position, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setYLoc(int y)\f1\par
\i\f0 Set the y position, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setYLoc(int x, int y)\f1\par
\f0 void setYLoc(Cord l)\f1\par
\i\f0 Set the position, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setXOffset(double x)\f1\par
\i\f0 Set the x position offset, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setYOffset(double y)\f1\par
\i\f0 Set the y position offset, in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 void setBGColor(int b)\f1\par
\i\f0 Set the background color by RGB value.\i0\f1\par
\kerning0\f0\par
\kerning1 void setFGColor(int f)\f1\par
\i\f0 Set the foreground color by RGB value.\i0\f1\par
\kerning0\f0\par
\kerning1 void setIconIndex(int i)\f1\par
\i\f0 Set the icon, but its index on the TilePalette.\i0\f1\par
\kerning0\f0\par
\kerning1 void setImage(BufferedImage image)\f1\par
\i\f0 Set the image being used. You normally shouldn't call this, as it is not reverse coupled to FG color, BG color, or image index. Let the TilePalette do its thing.\i0\f1\par
\kerning0\f0\par
\kerning1 void setParentPalette(TilePalette p)\f1\par
\i\f0 Set the TilePalette that governs this tile.\i0\f1\par
\kerning0\f0\par
\kerning1 void setSizeMultiplier(double sm)\f1\par
\i\f0 Set the multiplier that the TilePalette uses to generate the tile's image.\i0\par
\par
void setSizeMultiplierAndRender(double sm)\par
\i Update size multiplier and replace the stored image by generating a new one from the palette.\i0\f1\par
\kerning0\f0\par
\kerning1 void setBGType(boolean b)\f1\par
\i\f0 Set the background type used for image generation, either  BOX_BACKGROUND or CIRCLE_BACKGROUND. For no background, use either with a fully transparent BG color.\i0\f1\par
\kerning0\f0\par
\kerning1 void setLifespan(int l)\f1\par
\i\f0 Set the lifespan, in ticks, of this tile.\i0\f1\par
\kerning0\f0\par
\kerning1 void setAge(int a)\f1\par
\i\f0 Set the current age, in ticks, of this tile. You shouldn't really ever need to do this manually, unless resetting the age for some reason.\i0\f1\par
\kerning0\f0\par
\kerning1 void setyGravity(double g)\f1\par
\i\f0 Set acceleration due to gravity (y axis). Should normally be a negative number, in tiles per tick. Has no effect unless the tile is also affected by gravity.\i0\f1\par
\kerning0\f0\par
\kerning1 void setAffectedByAge(boolean aba)\f1\par
\i\f0 Set whether or not this tile expires due to age.\i0\f1\par
\kerning0\f0\par
\kerning1 void setVisible(boolean v)\f1\par
\i\f0 Set whether or not this tile should be drawn.\i0\f1\par
\kerning0\f0\par
\kerning1 void setAffectedByGravity(boolean ag)\f1\par
\i\f0 Set whether or not this tile should be affected by gravity.\i0\f1\par
\kerning0\f0\par
\kerning1 void setTerminalVelocity(int tv)\f1\par
\i\f0 Set the minimum y speed this tile can attain, if affected by gravity, in tiles per tick. Note that by minimum, I mean \ldblquote largest negative y value.\rdblquote\i0\f1\par
\kerning0\f0\par
\kerning1 boolean isExpired()\f1\par
\i\f0 Returns true if this tile is expired, either by age or manually.\i0\f1\par
\kerning0\f0\par
\kerning1 void forceExpire()\f1\par
\i\f0 Set this tile as expired, to be cleaned up by the TileAnimationManager.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 Vect (class)\ulnone\b0\f1\fs24\par
\f0 Implements: WSConstants\f1\par
\i\f0 A simple mathematical vector system for WidlerSuite. Plays nicely with Coord. More or less a struct.\i0\f1\par
\kerning0\f0\par
\kerning1 double angle\f1\par
\i\f0 In radians.\i0\f1\par
\kerning0\f0\par
\kerning1 double magnitude\f1\par
\i\f0 The other public member.\i0\f1\par
\kerning0\f0\par
\kerning1 Vect()\f1\par
\i\f0 Empty constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 Vect(double theta, double length)\f1\par
\i\f0 Double constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 Vect(double theta, int length)\f1\par
\i\f0 Double/int constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 Vect(Coord cart)\f1\par
\i\f0 Constructor that converts a Coord to a Vect (converts Cartesian to polar coordinates).\i0\f1\par
\kerning0\f0\par
\kerning1 Vect(Vect that)\f1\par
\i\f0 Basic copy constructor.\i0\f1\par
\kerning0\f0\par
\kerning1 Vect(Coord origin, Coord terminus)\f1\par
\i\f0 Constructor that sets the Vect to the vector that points from origin to terminus.\i0\f1\par
\kerning0\f0\par
\kerning1 Vect copy()\f1\par
\i\f0 Returns a deep copy of this.\i0\f1\par
\kerning0\f0\par
\kerning1 void set(double a, double m)\f1\par
\f0 void set(double a, int m)\f1\par
\f0 void set(Vect that)\f1\par
\i\f0 Sets the Vect based on the passed data.\i0\f1\par
\kerning0\f0\par
\kerning1 void set(Coord origin, Coord terminus)\f1\par
\i\f0 Sets the Vect equal to the difference of the passed Coords.\i0\f1\par
\kerning0\f0\par
\kerning1 void set(Coord cart)\f1\par
\i\f0 Converts the Coord from Cartesian to polar coordinates, then sets this to that.\i0\f1\par
\kerning0\f0\par
\kerning1 int getX()\f1\par
\i\f0 Converts the Vect to Cartesian coordinates and returns the x component.\i0\f1\par
\kerning0\f0\par
\kerning1 int getY()\f1\par
\i\f0 Converts the Vect to Cartesian coordinates and returns the y component.\i0\f1\par
\kerning0\f0\par
\kerning1 double getXAsDouble()\f1\par
\i\f0 Converts the Vect to Cartesian coordinates and returns the x component.\i0\f1\par
\kerning0\f0\par
\kerning1 double getYAsDouble()\f1\par
\i\f0 Converts the Vect to Cartesian coordinates and returns the y component.\i0\f1\par
\kerning0\f0\par
\kerning1 void add(Vect that)\f1\par
\i\f0 Adds another Vect to this one. Can result in loss of precision, as it converts to Coords which are int-based.\i0\f1\par
\kerning0\f0\par
\kerning1 void add(Coord that)\f1\par
\i\f0 Adds a Coord to this by converting this to a Coord, adding, and converting back to a Vect.\i0\f1\par
\kerning0\f0\par
\kerning1 boolean equals(Vect that)\f1\par
\i\f0 Checks for equality.\i0\f1\par
\kerning0\f0\par
\kerning1 Coord getAsCoord()\f1\par
\i\f0 Converts this to a Coord and returns the result.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 Voronoi (class)\ulnone\b0\f1\fs24\par
\i\f0 An implementation of Voronoi diagramming.\i0\f1\par
\kerning0\f0\par
\kerning1\i Accepts a list of points and an array size, returns a Voronoi map. The map is represented\i0\f1\par
\i\f0 as a two-dimensional int array, with the value stored being the Vector index of the point\i0\f1\par
\i\f0 closest. A second two-dimensional array is used internally to track best so far during generation.\i0\f1\par
\kerning0\f0\par
\kerning1 static boolean ANGBAND\f1\par
\f0 static boolean TRUE_DIST\f1\par
\i\f0 Mode flags for determining distance. True distance is the default.\i0\f1\par
\kerning0\f0\par
\kerning1 // only functions\f1\par
\f0 static int[][] generate(Vector<Coord> pointList, Coord size)\f1\par
\f0 static int[][] generate(Vector<Coord> pointList, int sizeX, int sizeY)\f1\par
\f0 static int[][] generate(Vector<Coord> pointList, Coord size, boolean distType)\f1\par
\f0 static int[][] generate(Vector<Coord> pointList, int sizeX, int sizeY, boolean distType)\f1\par
\i\f0 Returns a 2D array, where each element contains the index of the point to which it is closest.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 WSConstants (interface)\ulnone\b0\f1\fs24\par
\i\f0 Constants for WidlerSuite. Used by a variety of classes.\i0\f1\par
\kerning0\f0\par
\kerning1 static final int RECT_MODE\f1\par
\f0 static final int HEX_MODE\f1\par
\i\f0 Mode flags, for classes that need to differentiate between rectangular mode and pseudo-hexagonal mode.\i0\f1\par
\kerning0\f0\par
\kerning1 static final boolean SEARCH_DIAGONAL\f1\par
\f0 static final boolean DONT_SEARCH_DIAGONAL\f1\par
\i\f0 Mode flags for rect mode; whether or not diagonal stepping is legal.\i0\f1\par
\kerning0\f0\par
\kerning1 // adjacency lists: x, y, stepCost\f1\par
\f0 static final int[][] RECT_ORTHO\f1\par
\f0 static final int[][] RECT_DIAG\f1\par
\f0 static final int[][] HEX_EVEN_ROW\f1\par
\f0 static final int[][] HEX_ODD_ROW\f1\par
\i\f0 Lists of the offsets of adjacent tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 static final int NE, E, SE, SW, W, NW\f1\par
\i\f0 Enumerators for hexagonal stuff.\i0\f1\par
\kerning0\f0\par
\kerning1 static double GRAVITY\f1\par
\i\f0 Acceleration due to gravity in tiles per tick per tick.\i0\f1\par
\kerning0\f0\par
\kerning1 static int FRAMES_PER_SECOND \f1\par
\i\f0 A bunch of stuff needs to know fps to properly display. Default is 30 fps.\i0\f1\par
\kerning0\f0\par
\kerning1 final static double FULL_CIRCLE\f1\par
\f0 final static double THREE_QUARTER_CIRCLE\f1\par
\f0 final static double HALF_CIRCLE\f1\par
\f0 final static double QUARTER_CIRCLE\f1\par
\f0 final static double EIGHTH_CIRCLE\f1\par
\f0 final static double SIXTH_CIRCLE\f1\par
\f0 final static double TWELFTH_CIRCLE\f1\par
\i\f0 Commonly used angles in radians, to avoid a bunch of unnecessary calculations.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 WSFontConstants (interface)\ulnone\b0\f1\fs24\par
\i\f0 Constants used to reference tiles on WSFont_16x16 and WSFont_8x16. Names are strongly based on the names from CP437, but are not always identical. Interface consists of a large list of final static ints. Not reproduced here for brevity.\i0\f1\par
\kerning0\f0\par
\kerning1\ul\b\fs28 WSTools (class)\ulnone\b0\f1\fs24\par
\f0 Implements: WSConstants\f1\par
\i\f0 A collection of utility functions which can be called statically. WSTools also contains a static random number generator, to centralize use.\i0\f1\par
\kerning0\f0\par
\kerning1 static double random()\f1\par
\i\f0 Returns a random number between 0.0 and 1.0 exclusive.\i0\f1\par
\kerning0\f0\par
\kerning1 static int random(int n)\f1\par
\i\f0 Returns a random positive integer from 0 to (n-1) inclusive.\i0\f1\par
\kerning0\f0\par
\kerning1 static Color randomColor()\f1\par
\i\f0 Returns a random color.\i0\f1\par
\kerning0\f0\par
\kerning1 static int roundToInt(double value)\f1\par
\i\f0 Rounds a double to an int.\i0\f1\par
\kerning0\f0\par
\kerning1 static int roundToEven(double value)\f1\par
\i\f0 Rounds to an intiger, but .5 rounds to the nearest even int.\i0\f1\par
\kerning0\f0\par
\kerning1 static double simplifyAngle(double angle)\f1\par
\i\f0 Removes full circles (including negative circles) from an angle.\i0\f1\par
\kerning0\f0\par
\kerning1 static int minMax(int min, int value, int max)\f1\par
\i\f0 Bounds an int by the passed values.\i0\f1\par
\kerning0\f0\par
\kerning1 static double minMax(double min, double value, double max)\f1\par
\i\f0 Bounds a double by the passed values.\i0\f1\par
\kerning0\f0\par
\kerning1 static double pathDistance(Coord origin, Vector<Coord> path, double diagonalCost)\f1\par
\f0 double pathDistance(Coord origin, Vector<Coord> path)\f1\par
\i\f0 Returns the walking distance of a passed path. Assumes that the passed vector contains a sequential list of adjacent cells.\i0\f1\par
\kerning0\f0\par
\kerning1 static String doubleToPercent(double d)\f1\par
\i\f0 Returns a string representing a double as a (integer) percentage. Ex: .346 returns "34%".\i0\f1\par
\kerning0\f0\par
\kerning1 static int getAngbandMetric(Coord start, Coord end)\f1\par
\f0 static int getAngbandMetric(int startX, int startY, int endX, int endY)\f1\par
\i\f0 Returns all the long axis plus half the short axis.\i0\f1\par
\kerning0\f0\par
\kerning1 static int getDistanceMetric(Coord start, Coord end)\f1\par
\f0 static int getDistanceMetric(int startX, int startY, int endX, int endY)\f1\par
\i\f0 Returns the square of the hypotenuse; used for quickly calculating which of several distances is longer and you don't care what the actual distance is.\i0\f1\par
\kerning0\f0\par
\kerning1 static double getDistance(Coord start, Coord end)\f1\par
\f0 static double getDistance(int startX, int startY, int endX, int endY)\f1\par
\i\f0 Returns the actual distance between two points.\i0\f1\par
\kerning0\f0\par
\kerning1 static double interpolateLinear(float p1, float p2, float xOff)\f1\par
\i\f0 Returns the value of a point between two values.  For example, if the passed values are 2 and 4, and the xOffset is .5 (halfway between the two), this will return 3.\i0\f1\par
\kerning0\f0\par
\kerning1 static double interpolateCosine(float p1, float p2, float xOff)\f1\par
\i\f0 Returns a value similar to interpolateLinear(), but on an s-curve so that results are more heavily weighted towards the closer of the two points.\i0\f1\par
\kerning0\f0\par
\kerning1 static double getRatio(int cur, int max)\f1\par
\f0 static double getRatio(double cur, double max)\f1\par
\i\f0 Returns the the fractional portion of max which cur is as a double.\i0\f1\par
\kerning0\f0\par
\kerning1 static Coord getHexIndex(double x, double y)\f1\par
\f0 static Coord getHexIndex(double x, double y, boolean roundToEven)\f1\par
\i\f0 Returns the index of the tile in which the pixel lies, accounting for hex offset. x and y are in tiles.\i0\f1\par
\kerning0\f0\par
\kerning1 static double getHexX(int rectX, int rectY)\f1\par
\f0 static double getHexX(Coord c)\f1\par
\i\f0 Returns the actual x position of a passed hex tile (every odd row is indented by .5 tiles).\i0\f1\par
\kerning0\f0\par
\kerning1 static Coord[] getAdjacentHexes(int originX, int originY)\f1\par
\f0 static Coord[] getAdjacentHexes(Coord origin)\f1\par
\i\f0 Returns the indices of the six hexes adjacent to the passed location.\i0\f1\par
\kerning0\f0\par
\kerning1 static double getAngle(double x, double y)\f1\par
\i\f0 Returns the angle from 0, 0 to the passed point.\i0\f1\par
\kerning0\f0\par
\kerning1 static Color[] getGradient(Color startColor, Color endColor, int steps)\f1\par
\i\f0 Returns an array that smoothly transitions from startColor to endColor in a specific number of steps.\i0\f1\par
\kerning0\f0\par
\kerning1 static Color[][] getBlit(int width, int height, BufferedImage src)\f1\par
\i\f0 Copies a passed image into a color map of that is [width][height] in size.\i0\f1\par
\kerning0\f0\par
\kerning1 static Vector<Coord> getLocalMaxima(int[][] noiseMap)\f1\par
\f0 static Vector<Coord> getLocalMaxima(double[][] noiseMap)\f1\par
\i\f0 Returns a vector containing the the local maxima on the passed map (checks orthogonally, does not search edges). \i0\f1\par
\kerning0\f0\par
\kerning1 static Vector<Coord> getLocalMinima(int[][] noiseMap)\f1\par
\f0 static Vector<Coord> getLocalMinima(double[][] noiseMap)\f1\par
\i\f0 Returns a vector containing the the local minima on the passed map (checks orthogonally, does not search edges). \i0\f1\par
\par
}
 